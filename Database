達人に学ぶDB設計徹底指南書

はじめに
①論理設計
正規化やER図といった道具を使ったデータのモデル設計。
一般的に「データベース設計」と聞いて、多くの人が思い浮かべる分野

②物理設計
サーバーやストレージといった物理的なハードウェアレベルの設計。

③実装設計
特定のデータベース製品を前提に、具体的な構築の手順や方法を解説したもの。


第1章
データベースを制する者はシステムを制す

「データベース」と「DBMS」は異なる。「データベース」はデータの集積を指す論理的概念である。
「DBMS」は「データベース」を実装したソフトウェアを指す。

データベース設計を考える際は、データベースを外部スキーマ、概念スキーマ、内部スキーマの3層に分けて考える。

1-1
システムとデータベース

データ処理としてのシステム
「データベース」とは「データの集まり」を指すために使われる言葉で、
そのデータベースを管理するためのシステムを「DBMS」と呼ぶ。

今日のシステムの中で、データベースを持っていないシステムは存在しない。
システムを構成する部品的なプログラムの中にはデータベースを持たないものもあるが、
一つのサービスという全体的な観点からみれば、そこには必ずデータベースが存在している。


勘どころ1
データベースを使わないシステムは、この世に存在しない。


データと情報
データとは、ある形式（フォーマット）に揃えられた事実

勘どころ2
情報はデータと文脈を合成して生まれる。

システムとは、このデータと情報の区別という観点から見た場合
ユーザーが、システムにデータを登録し、さらにそれを引き出して情報を作り出す、
という一連のサイクルの中に位置づけることもできる。
このような部品を「モジュール」と呼ぶ。


1-2
データベースあれこれ

データベースの代表的なモデル
リレーショナルデータベース（Relational Database: RDB）
関係データベースとも呼ばれ、現在最も広く利用されているデータベース。
IT業界では、「データベース」と言えば、リレーショナルデータベースを指す。

データを人間が理解しやすい二次元表の形式で管理するため、
データの取り扱いが他のデータベースに比べると直感的で簡単。


オブジェクト指向データベース（Object Oriented Database: OODB）
オブジェクトをデータベースに保存するために作られたのが、オブジェクト指向データベース


XMLデータベース（XML Database: XMLDB）
Web上でやり取りされるデータの形式にXMLが普及している。
このXML形式のデータを扱うことのできるデータベースとして開発されたのが、
XMLデータベース。
リレーショナルデータベースが苦手とする階層構造のデータの扱いを得意とする。


キー・バリュー型ストア（Key-Value Store: KVS）
データをKey（識別キー）とValue（値）の組み合わせただけの単純なデータ型で
表現するデータベース。
単純なデータ問い合わせを高速化することを目的としており、
大量データを高速に処理する必要のあるWebサービスで多く利用される。
その反面複雑なデータ操作は苦手。


階層型データベース（Hierarcical Database: 省略は特になし）
データを階層構造（木構造）で表現するデータベース。
リレーショナルデータベースより一世代前の主流データベース。

勘どころ3
データベースのモデルが異なれば、データフォーマットも異なる。
モデルが異なれば設計技法も異なる。


DBMSの違いは設計に影響するか？
主なDBMS
リレーショナルデータベースでもDBMSにはいくつか種類がある。
・Oracle Database
・SQL Server
・DB2
・PostgreSQL
・MySQL


勘どころ4
DBMSが異なっても、（基本的には）設計の方法は影響を受けない。


1-3
システム開発の工程と設計

システム開発の設計工程
開発は、建築と同様、いくつかの工程（ステップ）に分解することができる。

①要件定義
②設計
③開発（実装）
④テスト

①要件定義
システムが満たすべき機能やサービスの水準、すなわち要件を決める工程。
通常は何からの形で外部の顧客と要件を合意するが、パッケージソフトやWebサービスの場合は、
自社内のみで要件を定義することもある。
②設計
定義された要件を満たすために必要なシステムを作るための設計（デザイン）を行なう工程。
建築で言えば、実際に作る前に図面を引く作業に相当する。
本書で焦点を当てる工程はこの設計工程なのですが、この工程はさらに細分化して考える必要がある。


③開発（実装）
設計書に従ってシステムを実際に作る工程。
なお、「システムを実際に作る」ことをIT業界では「実装する（implement）」と言う（DBMSをデータベースの「実装」と呼ぶのと同じ意味です）
この工程は、一般的にはプログラマによるコーディングを指すことが多いが、それ以外にもサーバーやネットワーク機器、
ストレージといったハードウェアの調達や環境の物理的構築といった作業も含まれる。


④テスト
実装によって組み上がったシステムが、本当に実用にたえる品質であるかを試験（テスト）する工程。
目的に応じてテストの種類とレベルにも何種類かありますが、大きくは機能的な品質に対するテストと、
性能や信頼性といった非機能品質に対するテストの二種類に大別できる。


設計工程と開発モデル
ウォーターフォールモデル
「滝（waterfall）」という名前が示すとおり、要件定義→設計→開発→テスト、というように一つずつ工程を踏んで、
段階的にシステムを作っていく。滝が逆流することがないように、基本的に工程が逆戻りすることはない。
これは、建物や橋など建築物を造るときの方法でもあります。
「家を作っていてあまりうまくいかなそうなので、もう一度図面から引きなおしましょう」というのは、
時間とお金の無駄が大きすぎるので、まずありえない。
つまり、手戻りが難しく、改修が高コストになりがちです。
ウォーターフォールモデルは、大規模なシステム開発において採用されることが多いが、
手戻りがきかないということは、各工程をきっちり仕上げる精密さが要求される、ということでもある。


プロトタイピングモデル
もう一方のプロトタイピングも、「試作品（prototype）」という名前が内容を表わしている。
最初に小さな試作品を作って顧客やユーザーに見せてフィードバックをもらい、
それを取り入れた形で改良版を作って顧客やユーザーに見せて……というサイクルを繰り返す循環的な開発手段。
早い段階からシステムの具体的なイメージを開発者や顧客と共有できるため、要件定義の取りこぼしや意思疎通の齟齬を防げるというメリットがある一方で、
何度も同じ工程を繰り返す必要があり、変更を繰り返すうちに発散して収拾がつかなくなる、というリスクもある。
こうした特性から、普通は小規模のシステムに対して適用される。


1-4
設計工程とデータベース
なぜデータベースが重要か
理由1
システムにおいて大半のデータ（少なくとも永続的に使用されるデータ）はデータベース内に保持される。
そのため、普通、データ設計とはデータベース設計とほぼ同義である。

理由2
データ設計がシステムの品質を最も大きく左右する。ソフトウェアというのは、言ってみれば「データの流通機構」であって、
どのようなプログラムが必要になるかは、どのようなデータをどういうフォーマットで設計するかに左右される。


DOAとPOA
このうち特に重要なのが理由1。近年のソフトウェア開発では、データ中心アプローチ（Data Oriented Approach:DOA）という考え方が主流。
これは、文字通りシステムを作る際に、プログラムよりも前にデータの設計から始める方法論。
スローガン的に言えば「最初にデータありき」。

DOAは、POAの欠点を克服するために登場しました。
その着眼のポイントは、データがあまり変化しない（永続的）という点。
したがって、データの意味や形式が先に決まっていれば、複数のプログラムで共用することも容易で、
業務要件の仕様変更にも柔軟に対応できるというメリットが得られる。

システム開発においては、プログラム設計に先立ってまずデータ設計が優先される。

勘どころ5
最初にデータがある。プログラムはその次にできる。

データ設計——それは現在ではほぼデータベース設計と同義なのですが——システムの品質を決める最も重要な要因と言っても過言ではない。
このデータ設計においてセオリーを踏み外した設計（バッドノウハウ、またはアンチパターンと呼びます）を行なってしまうと、
システムの機能／非機能の品質を致命的に損なうことになる。

勘どころ6
データベースを制する者がシステムを制す。データベースは、システムの中心であると同時にシステム開発の中心でもある。


3層スキーマ
重要な概念として登場するのが、「スキーマ（schema）」という概念。
「枠組み」や「構図」という意味の単語。データベース設計においては、
データベースのデータ構造やフォーマットという意味で使う。
データベース設計のステップは、このスキーマのレベルと密接に結びついている。
スキーマは、一般的に三つのレベルに分類される。


外部スキーマ（外部モデル）= ビューの世界

概念スキーマ（論理データモデル） = テーブルの世界

内部スキーマ（物理データモデル） = ファイルの世界

この三つのスキーマに基づいてシステムを記述したモデルを
「３層スキーマモデル」と呼ぶ。

外部スキーマ
外部スキーマとは、システムの利用者であるユーザーから見て、データベースがどのような機能とインタフェースを持っているかを定義するスキーマ。
いわば「ユーザーから見たデータベース」の姿。
データベースのオブジェクトとしては、ビューが相当する。
このスキーマは、データベースだけでなく、画面のユーザーインタフェースや入力データなど、
ユーザーから見える「システムの姿」の一部である、と言うこともできる。


概念スキーマ
データベースに保持するデータの要素および、データ同士の関係を記述するスキーマ。
外部スキーマがユーザーから見たデータベースだとすれば、概念スキーマは「開発者から見たデータベース」。
必然的に、データベース設計において重要な位置を占めることになる。
概念スキーマの設計を「論理設計」とも呼ぶ。
データベース設計の中心となるスキーマである。


内部スキーマ
概念スキーマで定義された論理データモデルを、具体的にどのようにDBMS内部に格納するかを定義するスキーマ。
「DBMSから見たデータベース」です。テーブルやインデックス（索引）の物理的定義を含む。
リレーショナルデータベースもコンピュータ上で動く以上は、あらゆるデータは最終的に「ファイル」の形で管理されるわけで、
その「ファイル」で表現される世界だ、と考えていただければ良い。
内部スキーマの設計を、論理設計との対比で「物理設計」と呼ぶ。


概念スキーマとデータ独立性
概念スキーマがなかった場合、ユーザーが「データの見え方を変えたい」と思った場合、
もちろん外部スキーマは変更が必要になるのですが、それだけでなく、内部スキーマまで変更の必要が出てくることがある。
これと反対に、内部スキーマに変更を行なう場合にも、外部スキーマが影響を受けてしまうことが起こる。
2層スキーマでは、スキーマ同士の独立性が低く（=依存性が高く）なり、変更に弱いシステムができあがってしまう。
概念スキーマというのは、外部スキーマと内部スキーマの間に位置することで、両者の変更が互いに影響し合わない
ようにするための、緩衝材の役割を果たしている。
スキーマの独立性のことを、データ独立性と呼ぶ。外部スキーマからの独立性を論理的データ独立性、内部スキーマからの
独立性を物理的データ独立性と呼ぶ。


勘どころ7
概念スキーマはデータ独立性を保証するためにある。

勘どころ8
概念の有用性がなかったら、「それがなかったらどうなるか」を考えてみる。

勘どころ9
DBMSのマニュアルは熟読せよ。


演習問題
演習1-1
DBMSの情報確認

演習1-2
アプリケーション改修のタイプとコスト
問題に対して、実装および設計に対してどのような変更によって解決が可能か、思いつくだけの方法を提案する
問題1
性能試験において、ある夜間バッチ処理のSQLの性能が非常に悪く、要件上は1時間で終了するべきSQLが10時間かかることがわかった。

・SQLのアクセスパスを最適化する

・アプリケーションの改修を行なう

・テーブルのレイアウトを変更する

問題2
画面からオンラインで出力する帳票において、現在のレイアウトでは情報が不足していることがわかった。
顧客との要件調整に漏れがあったことが原因だった。

・必要な情報を付加したデータマートを追加する




第2章
論理設計と物理設計
データベース設計は、大きく論理設計（概念スキーマ）と物理設計（内部スキーマ）に分けられる。
それぞれのポイントを示すとともに、信頼性（可用性）、性能、キャパシティといったデータベースに求められる要件を満たすため、
どのような観点に注意して設計を行なうべきかを学ぶ。


・論理設計は物理設計に先立つ。少なくともそう意識していなければいけない。
・DBMSはユーザーに「ファイル」を極力意識させないようにしているが、設計者はファイルレベルで考えるのが物理設計のポイント。
・サイジングは難しい。
・RAIDは信頼性、性能、そして”財布”を考慮して決める。
・バックアップおよびリカバリの設計は地味なタスクだが、おそろかにすると”新聞に載る”。


2-1
概念スキーマと論理設計
概念スキーマを定義する設計を、論理設計と呼ぶ。
システムの世界では「論理」という言葉がよく登場するが、通常の「整合的で筋道が通っている」と言う意味ではなく、
「物理層の制約にとらわれない」という意味で使う。

物理層の制約とは、たとえばデータベースサーバーのCPUパワーや、ストレージのデータ格納場所やもう少し上位のレベルで言うと、
DBMSで使えるデータの方やSQLの構文、といった、より具体的で実装レベルの条件のこと。

システム開発におけるデータベースの設計は、次の手順で行う。
1、概念スキーマ（論理設計）
2、内部スキーマ（物理設計）

論理設計が物理設計より前に位置しているのは、この設計が物理的制約には、原則として依存しないことを示している。


論理設計のステップ
1.エンティティの抽出
2.エンティティの定義
3.正規化
4.ER図の作成

エンティティの抽出
勘どころ10
「エンティティ（実態）と言っても、物理的実態を伴う必要はない。」

リレーショナルデータベースでは、こうした現実世界のエンティティを、最終的に
「テーブル」という物理的単位で格納していくことになる。
まずは、システムのためにどのようなエンティティ（=データ）が必要になるかを抽出することが、
論理設計の第1ステップ。


エンティティの定義
エンティティを抽出した後は、書くエンティティがどのようなデータを保持するかを
決める必要がある。エンティティは、データを「属性（attribute）」という形で保持する。
これは二次元表における「列」と同義だと考える。
ここで特に重要なのは、「キー（key）」という列を定義すること。
キーとは、ある特定の列の値を決定するための列のこと。


正規化
正規化（normalization）は、エンティティ（テーブル）について、システムでの
利用がスムーズに行えるよう整理する作業。
特に、正規化は更新（データの登録、変更、削除）が整合的に行えるように、エンティティのフォーマットを
整理することが重要な目的。
リレーショナルデータベースの論理設計においては、この正規化が最も重要な土台をなす。
正規化は、データベースの論理設計を理解する鍵と言っても過言ではない。


ER図の作成
ER図は、Entity-Relationship Diagram の略。
正規化を行うと、エンティティの数が増える。正規化とは、エンティティ（テーブル）を細かく分割していく作業。
エンティティ同士の関係を表現する図を作成する、いわば「エンティティの見取り図」


2-2
内部スキーマと物理設計
物理設計は、論理設計の結果を受けて、データを格納するための物理的な領域や格納方法を決める工程。
物理層にはハードウェアを含むため、必然的にこの工程を行うためには、
ハードウェアやDBMSの個々の製品についての知識が必要になる。


物理設計のステップ
1.テーブル定義
2.インデックス定義
3.ハードウェアのサイジング
4.ストレージの冗長構成決定
5.ファイルの物理配置決定

1.テーブル定義
論理設計で定義された概念スキーマをもとに、それをDBMS内部に格納するための
「テーブル」の単位に変換していく作業。
論理設計で作られるERモデルを「論理モデル」と呼ぶのに対し、このフェーズで作られるモデルを
「物理モデル」と呼ぶ。


2.インデックス定義
インデックス（索引）はリレーショナルデータベースにおいてテーブルと並んで重要な概念。
インデックスは、なくても機能的には何の問題もない。データベースはきちんと機能する。
インデックスが重要な役割を果たすのは、非機能部分、つまりパフォーマンス。


3.ハードウェアのサイジング
「サイジング」という言葉は、「サイズ（大きさ）」に由来している。「大きさを決める」という意味で、
システム開発では2種類の意味で使う。
一つは、データの規模を問題にする場合で、
「システムで利用するデータサイズを見積り、それに十分な容量の記憶装置（ストレージ）を選定する」
という意味。
ここでは、文字通りのデータの「サイズ（規模）」が重要。
「キャパシティの見積り」と言い換えることもできる。
サイジングのもう一つの意味は、パフォーマンスに関わる使い方。
サイズを測る対象はサーバーのCPUやメモリ。
システムが十分な性能を発揮できるだけのスペックのCPUやメモリを持ったサーバを選定すること。
ストレージもサイジングの対象。機能性のほとんどはストレージのI/Oネックによって引き起こされる。

勘どころ11
サイジングはキャパシティとパフォーマンスの2つの観点から行う。

勘どころ12
データベースの性能問題の8割はディスクI/Oによって起きる。

データベースにおいては、データの整合性とパフォーマンスの間に強いトレードオフが存在する。
整合性を高くしようとするとパフォーマンスが犠牲になり、パフォーマンスを追求すると整合性を犠牲にする
という二律背反の原則。

キャパシティのサイジング
システムで利用するデータ量
データベース内に格納するデータ量は、物理的なテーブル定義およびインデックス定義が終わらなければ算出できない。
この作業を実施するには、論理設計の終了が前提条件。
ここでのデータ量には、データベース内に格納するテーブル以外にも、テキストや画像、HTMLとうさまざまな
形式のファイル文も加算する必要がある。

サービス終了時のデータ増加率
データ量というのは、システムん運用開始から、基本的には増えていく。
システムの運用終了時にデータ量がどの程度増えるかを見越しておかないと、
途中でストレージの内容が足りなくなってしまう。

実際、データ量を正確に見積もることが難しい場合もある。
これに対しては、
①安全率を大きくとって、余裕を持たせたサイジングを行う。
②仮に後で容量が不足した場合に、簡単に記憶装置を追加できるような構成にしておく。

②のような後からの拡張性が簡単な構成を、「スケーラビリティが高い」と表現する。

パフォーマンスのサイジング
性能要件
通常、システム開発では性能性要件を二つの指標を使って定義する。
一つが処理時間。特定の処理について「何秒いないに終了すること」といった形で定義する。
もう一つの要件が、スループット。これは単位時間当たりにどれだけの処理をシステムがこなせるかを示す。
処理時間が「どれだけ速く処理できるか」の指標で、スルートップは「どれだけたくさん処理できるか」の指標。
この単位は「1秒あたり仕事量」を示すTPS（Transaction Per Second）という指標を使う。
この二つの要件を、要件定義の段階で決めておく必要がある。

勘どころ13
性能要件の指標は二つ。「どれだけ速いか」と「どれだけ多いか」。


リソース使用量の基礎数値
ゼロから構築する場合に問題になる、どの程度の処理を行うと、どの程度のハードウェアリソースを消費するのか、
という相関関係は、机上では見えにくい。
したがって、何か別の情報から類推するしかないが、それにしても根拠となる基礎数値が必要。

基礎数値を得る方法は二つある。
①類似の稼働中のシステムのデータを流用する。
②開発初期段階でプロトタイプシステムを構築して、性能検証を実施する。

①は安上がりだが、適当な類似システムがみつからない場合は制度が低くなる。
②はきちんと実施すれば制度は高いが、プロトタイプの作成や検証実施に時間と人手がかかるため、
予算とスケジュールに余裕があるプロジェクトでないと実施が難しい。


勘どころ14
精度の高いサイジングは難しい。それゆえ、
・必ず実施時には安全率をかけること。
・スケーラビリティの高い構成を組むこと。

サイジングは、失敗すると被害が大きい割に、精度を高く行うのも難しいという、悩ましいタスク。


4.ストレージの冗長構成
ストレージは、データベースのデータを保持する媒体で、一般的にはHDDを使用する。
データベースに保管されるデータは、業務の基幹データなので、これを失うことは絶対に許されない。
そのため、可能な限り高い耐障害性を持つようにシステムを構築する必要がある。
ここで登場するのが「RAID」
RAIDはRedundant Array of Independent Disksの略で、日本語に訳すと
「独立したディスクの冗長配列」になる。
複数のディスクを束ねて仮想的に一つのストレージとする技術で、この単位でまとめられたディスクをRAIDグループと呼ぶ。
基本的な考え方は、複数のディスクに同じデータを書き込んで冗長化することで、そのうちの一本が壊れても
残りのディスクが生きていればデータを保全できるようにする、というもの。
冗長とは同じものを複数の場所に持つと言う意味。
RAIDは本来システムの信頼性（可用性）を高めるための技術なのですが、実はもう一つの利点が存在する。
それが性能向上。
ほとんどのレベルのRAIDでは、複数のディスクにデータを分散して保持する。
システムにおいて最も性能的にボトルネックとなるディスクI/Oを分散することで、パフォーマンス向上を
図ることができる。

勘どころ15
RAIDはシステムの信頼性と性能を共に改善できる技術。

データベースの物理設計においては、RAIDについて以下のことを考える必要がある。
・該当データには、信頼性がもとめられるのか、それとも性能が求められるのか
・どのようなレベルのRAIDを採用するか
・何本のディスクでRAIDを構成するか


RAID0
別名ストライピング
ストライプとは「縞々模様」のこと。
データを異なるディスクに分散して保持することからこの名前がついた。
I/O性能はディスク本数が増えるほど向上するが、ディスクのうち1本でも故障したらデータが失われるため
冗長性はまったくない。そのため、RAIDとは認めない人もいる。

RAID1
別名ミラーリング。
「鏡」という言葉のとおり、2本のディスクにまったく同じデータを持つ。
そのため、冗長性は1本だけの場合に比べて2倍になり、2本のディスクが同時に壊れない限り、データは保持される。
信頼性は1本のときより上がる。
データは分散されないので、性能は1本の場合と変わらない。
2本でひとつのデータを保持するので、ディスクの使用効率も良くない。

RAID5
パリティ分散と呼ばれる方式。
最低3本で構成し、データとともに「パリティ」と呼ばれる誤り符号訂正符号を分散して格納する。
ディスクが壊れたとしても、パリティから実データを復元することが可能。
1本までならばどのディスクが壊れてもデータを保全できる。
（2本のディスクが同時に壊れると、データが失われる。）
データを分散できるためI/O性能（読み出し）の向上も期待できる。
ディスク本数が増えるほど読み出し性能が向上する。
パリティの計算を行うため、書き込み性能は高くないが、通常、データベースは書き込みより読み出しデータ量が多いため、
読み出し性能が重視される。

RAID10
別名を「RAID1+0」とも呼ぶ。
その名前が意味するとおり、RAID1とRAID0を組み合わせたもの。
最初にRAID1のグループを二つ作り、そのグループを使ってRAID0を作る。
これは、RAID1とRAID0の「いいとこどり」を目論んだ方法で、RAID1の高信頼性と
RAID0の高速性を両立させる。
この方法の欠点は、必要になるディスクの本数が多いため、コストが高いこと
（最低でも4本が必要になる）

どのRAIDのパターンを採用するか？
信頼性や性能の要件、およびコストをトータルに勘案して決める必要があるので一概に正当はないが、
採用できるものならばRAID10が望ましい。
最低構成に必要なディスクが多く最もコストが高いため、財布に余裕がないと採用できない。

データベースとして絶対に採用してはならないのは、RAID0。
これは耐障害性が低いので、ディスクが1本壊れた瞬間に障害発生。


勘どころ16
データベースのRAIDは少なくともRAID5で構成する。
お金に余裕があればRAID10。RAID0は論外。



5.ファイルの物理配置
データベースのストレージの冗長構成が決まったら、物理設計の最終ステップは、
データベースのファイルをどのディスク（またはRAIDグループ）に配置するかを考える。
ファイル配置は、最近のDBMSでは自動化がっすんでいて、エンジニアが意識しなくても、
ある程度は自動的に配置してくれることもある。
データベースに格納されるファイルは、用途別に以下の5種類に大別できる。

①データファイル
②インデックスファイル
③システムファイル
④一時ファイル
⑤ログファイル

開発者が意識するのは、①データファイルと②インデックスファイルだけ。
このファイルは、「テーブル」のデータと、テーブルに付与されたインデックスのデータが格納される。

①データファイル
ユーザーがデータベースに格納するデータを保持するためのファイル。
テーブルのデータを格納するファイルであるため、業務アプリケーションが
SQLを通じて参照および更新を行うファイルでもある。
アプリケーションから見えるのはあくまで「テーブル」という論理単位であって、
「ファイル」が直接見えることはない。


②インデックスファイル 
テーブルに作成されたインデックスが格納されるファイル。
DBMSではテーブルとインデックスは普通異なるファイルとして管理される。
このファイルも、開発者が意識することはない。
SQLではテーブルへのアクセスを記述することはあっても、特定のインデックスに
対するアクセスを記述することはないから。
インデックスを使うかどうかは、DBMSが内部で勝手に判断するため、ユーザーも
インデックスの存在を意識することはない。


③システムファイル
システムファイルは、DBMSの内部管理用に使われるデータを格納する。
基本的に業務アプリケーションやユーザーがアクセスすることはない。


④一時ファイル
一時ファイルは、名前のとおり、DBMS内部での一時的なデータを格納するために使われる。
一時的なデータとは、たとえば、SQLで使われたサブクエリを展開したデータや、
GROUP BY句やDISTINCTを利用したときのソートデータなど。
一時データは、処理が終了すれば削除されてなくなるので①〜③までのファイルと異なり、
継続的にサイズが増加することはない。


⑤ログファイル
DBMSは、テーブルのデータに対する変更を受け付けた場合、即座にデータファイルを更新しているわけではない。
いったん、このログファイルに変更分を溜め込んだ後に、一括してデータファイルに変更を反映している。
DBMSによって呼び方が異なる。
このファイルも一時ファイルと同じで、データファイルに反映が終われば不要になるため、
継続的にサイズが増加するタイプのものではない。



5つのファイルのうち、最もファイルI/O量が多いのは①データファイル。
①の次にI/O量が多いのは、②インデックスファイルおよび④一時ファイル
この二つのファイルもできれば独立したディスク（RAIDグループ）に配置することが望ましい。


2-3
バックアップ設計

データベースの物理設計と隣接する領域に、データのバックアップおよび
リストアの設計がある。
データベースは、システムにとって極めて重要なデータが一元管理されており、
システムの心臓。
万が一にでもデータベース内のデータが失われるようなことがあってはならない。

事件を起こさないために必要な設計には、二通りの方針がある。
一つは、極力データを失わないような設計にすること。
これは先ほど解説したRAID設計が該当。
二つ目が、それでもなお、障害によってデータが失われたtきに、
復旧できりょうにしておくこと。
これが、バックアップとリカバリ。


バックアップの基本分類
普段、自宅や会社でパソコンを使っている時に使うバックアップは、ファイルのコピー。
システムにおけるバックアップも、基本的にはそのイメージの延長で考えれば良いが、
システムにおけるバックアップに「わかりにくい」というイメージを持っている人も少なくない。
大きな理由にバックアップにたくさんの種類があるから。


完全/差分/増分
主要な三つのバックアップ方式
①フルバックアップ（完全バックアップ）
②差分バックアップ
③増分バックアップ

データベースのバックアップ設計においては、三つの方式を組み合わせていく。
（どれか一つだけ、ということは普通ない）
この区分は、バックアップデータをどのような単位で分割するか、という基準に基づいていて、
「完全」とか「差分」は、その単位を示している。


フルバックアップ
フルバックアップ、または完全バックアップは、あらゆるバックアップ方式の基本で、最も単純で理解しやすい方法。
「フル（全部）」という言葉のとおり、ある時点でそのシステムで保持されているすべてのデータをバックアップする方式。
あるタイミングにおけるスナップショットを取るようなもの。

フルバックアップでほぞんされたファイルには、バックアップ時点のデータが全て含まれているから、そのファイルさえあれば、
バックアップ時点のデータをすべて復旧することが可能になる。

フルバックアップは、非常にシンプルでわかりやすく、残りの二つのバックアップ方式の基礎にもなる。
この方式だけでは運用ができないことが多い。

欠点1 バックアップの時間が長い
「長い」というのは、あくまで他のバックアップ方式と比べて、という相対的な意味。
具体的にどの程度時間がかかるかは、システムで扱うデータ規模やハードウェア性能に
依存するため、一概には言えない。

欠点2 ハードウェアリソースへの負荷が高い
「高い」というのも、あくまで他のバックアップ方式と比べて、という相対的な意味において。
バックアップするデータ量が多いということは、ストレージにおけるディスクI/O、サーバーのCPUおよび
メモリの使用量も増える、ということを意味する。


欠点3 サービス停止が必要
フルバックアップを取得するには、一般的にはDBMSなどのソフトウェアを停止し、
オンライン処理も閉塞した状態で実施する。
これは、データの整合性を保った状態でバックアップを取得しなければならない。
バックアップ中にデータが変更されてしまっては、データ整合性が取れない。

フルバックアップには運用上の厳しい制限が課せられている。
最近のシステムは24時間365日稼働も当たり前になってきていて、
サービスを停止できる時間は極力短くすることが、要件上求められるから、
半年や一年単位でしかフルバックアップを取らない、というシステムも珍しくない。



差分バックアップ
差分バックアップは、ログファイル（トランザクションログ）をバックアップすることで実現する。
おさらいで、DBMSは、ユーザーから受け付けた変更を、すぐにデータファイルに反映するのではなく、
いったんトランザクションログに溜め込む。（どんなDBMSでも）
トランザクションログには、データベース内のデータに対するあらゆる変更操作の履歴が残っている。
これをバックアップしておけば、データベースに対する変更操作をもう一度再現（リプレイ）
することが可能になる。

利点は、バックアップデータ量が減ること。フルバックアップを毎日繰り返していたのに対し、
差分バックアップを併用すれば対象は変更分のログファイルだけで済む。
これによって、バックアップ時間も短くなるほか、バックアップファイルを保管しておく
媒体の容量も小さくして節約できる。

欠点は、リカバリのときに、フルバックアップのファイルだけでなく差分のログも運用する必要があるため、
リカバリの手順が増えて時間も長くなること。
リカバリのためにはフルバックアップのファイルと、最新のログファイルの両方のファイルが正常に
使用できる必要がある。
どちらか一方でも壊れていたら、復旧はできない。



増分バックアップ
トランザクションログから一切の無駄を省いたバックアップ方式が、この増分バックアップ。
常に必要なログしかバックアップしない。
利点は、バックアップデータ量が三つの方式のうちで最小になること。
必然的に、バックアップに要する時間も最短となる。
バックアップファイルを保管するメディアの容量も最小で済む。
コスト的には最も優れた方式。

欠点は、リカバリ手順が最も複雑になること。
リカバリには全てのファイルが必要になる。
リカバリに要する時間も長くなる。
復旧に必要なファイルも増えるため、完全にデータを復旧できる可能性が
最も低くなる。



バックアップ方式にもトレードオフがある
「バックアップコストが低いほどリカバリコストは高い」というトレードオフの関係がある。


どんなバックアップ方式を採用すべきか？
ポイント1
いつ時点の状態に復旧させる必要があるか。そもそも復旧の必要があるか

ポイント2
バックアップに使用できる時間（バックアップウィンドウ）

ポイント3
リカバリに使用できる時間（リカバリウィンドウ）

ポイント4
何世代までのデータを残す必要があるか
（保管用の媒体サイズに影響）

選択肢を網羅すると4パターン
①バックアップしない
②フルバックアップのみ
③フルバックアップ+差分バックアップ
④フルバックアップ+増分バックアップ


勘どころ17
バックアップ方式は、「フルバックアップ+差分バックアップ」または
「フルバックアップ+増分バックアップ」が一般的。



2-4
リカバリ設計
バックアップ設計とリカバリ設計はセットで実施することが一般的。
これは、バックアップ方式によってリカバリ手順が左右される。
リカバリ設計は、バックアップ方式が決まれば、自動的に決まってくる。


リカバリとリストア
障害直前の状態にデータを復旧させるためには、単にバックアップファイルを
データベースに戻しただけではダメ。
そこからさらに、ユーザー変更分を再反映させなければ、リカバリは完結しない。

障害復旧の手順を厳密に2つに分ける必要がある。
「バックアップファイルを戻す」作業を「リストア」、そのファイルに対して、
トランザクションログを適用して変更分を反映する作業を「リカバリ」と呼ぶ。


リストアとロールフォワード
バックアップしておいたトランザクションログを適用することもリカバリだが、
実はトランザクションログは、DBMS内部にも残っている。
その中に、最後のバックアップ後に実施されたユーザーからの変更分も含まれている。
バックアップされていないだけで、データベースサーバーにはファイルとして残っている。
この末バックアップのトランザクションログまで適用することで、
初めてデータは障害直前の状態に復旧する。

リストアおよびリカバリの手順
1.フルバックアップのファイルをデータベースに戻す。→ リストア
2.差分または増分バックアップしていたトランザクションログを適用する。→ リカバリ
3.データベースサーバーに残っているトランザクションログを適用する。→ ロールフォワード

この手順を終えることで障害直前のデータが復旧される。


演習問題
演習2-1 データベースサーバーのクラスタリング構成
・Active-Standby方式
通常、動いているのは現用系（Active）だけで、もう一方の待機系（Standby）は
全く処理をしない。現用系に障害が発生した場合には待機系に切り替わり、
少ない停止時間でシステムが復旧できるという利点がある。
復旧の速度が速い方式としてホットスタンバイ方式、
復旧の速度が遅い方式としてコールドスタンバイ方式がある。

コールドスタンバイ方式のほうがサーバーの光熱費やライセンス料が安くなるという
コストメリットがある。


・Active-Active方式
Active-Standby方式というのは、基本的にサーバー2台で構成し、動いているのは1台だけ。
性能はスタンドアロンと変わらない。
これにプラスして性能の向上も目指した方式が、Active-Active方式。
この構成は待機系というサーバーは存在せず、すべてのサーバーが現用系。
処理を各サーバーに分散することがで、かつ台数も（理論的には）特に限定せず増やしていくことが
できるので、信頼性のみならず性能的にも有利な方式と言える。

Active-Active方式にも、詳しく見ると2種類の方式がある。
一つ目がシェアードディスク方式。
これは、ディスクだけをサーバー間で共有して、CPU、メモリ、ネットワークといった資源は分離する構成。
この方式の利点は、どのサーバーからも共通のデータを参照/更新することができるため、
どのサーバーに障害が発生しても残りのサーバーで処理を継続することができる柔軟性がある。
一方で、共有資源となるディスクがボルトネックポイントになりやすく、それが原因でサーバー台数を
増やしても性能向上が頭打ちになってしまうという欠点がある。


二つ目がシェアードナッシング方式。
これは、ディスクを含むあらゆるリソースをサーバー間で共有しない方式。
構造的にボルトネックポイントを発生させないため、サーバー台数を並べることで
性能がどんどん上がっていう、という利点がある。
一方で、データの含まれるディスクを共有しないわけなので、各サーバーのアクセスできる
データは限られる。
特定のサーバーがダウンすると、残りのサーバーが稼働していても、
一部のデータにアクセスできない状態が発生する。



演習2-2 ハードウェアリソース情報取得
Windows : パフォーマンスモニタ
Linux/Unix系 :sar, vmstat, iostat, netstat


演習2-3 サーバーCPUの机上サイジング
現行システムにおいてすでに性能問題が発生しているということは、
現行のハードウェアリソースが不足している可能性を示唆している。
まずは現行システムのピーク時間帯におけるアクセスログと
ハードウェアリソースのログを確認する必要がある。

1.アクセスログを確認する
アクセスログからは、ピーク時間帯のレスポンスタイムとスループットを調べて、
性能要件で定義されている目標を達成しているかどうかをチェック。

2.ハードウェアリソースのログを確認する
現行システムのハードウェアリソースのログを調査して、ピーク時間帯に
リソースのキャパシティに限界が来ていないかを確認する。

サーバーの資源は、
・CPU使用率
・メモリ
・ディスク
・ネットワーク
の四つから構成されている。
このうちのどれか一つでも頭打ちになれば、そこがボルトネックになって、他の資源がどれだけ
余っていても有効活用することができなくなる。

CPUがピーク時間帯に定常的に90%程度と高止まりすることがわかった。
他のリソースには余裕があるので、CPUがボルトネックになっている。
新しいCPUで増強することに意味がある。

3.新旧サーバーの性能比を算出する
現行のサーバーと新サーバーのCPUの性能比を算出すること。



第3章
論理設計と正規化
〜なぜテーブルは分割する必要があるのか？〜

論理設計の中心である正規化について。正規化が何を目的に、どのような理論に従って
行われているのかを理解することで、データベースに格納されるデータを整合的に保持するための方法論を身につける。

学習のポイント
・リレーショナルデータベースにおけるテーブルとは、「同じ種類の物の集合」のこと
・「キー」とは、ある情報を引き出すための鍵。特に、テーブルで最も重要なのが「主キー」
・「正規化」は、データの冗長性をなくしていく作業。
  その目的は更新時のデータ不整合を防止することにある。
・正規化を理解するためには、関数属性の概念を理解する必要があるが、
  これの基礎になっているのが「キー」の概念。
・正規化を進めていくほどデータ整合性は高まるが、検索性能が劣化する。
  通常は第3正規形までを考えれば十分。


3-1
テーブルとは何か？

リレーショナルデータベースは、あらゆるデータを「テーブル」という単位で扱う。
テーブルは、見た目上は「表」と良く似ている。
テーブルと表は、厳密には同じものではない。

二次元表≠テーブル
テーブルとは、ただ形だけ二次元表であるだけではダメで、
「ある共通点を持ったレコードを集めたもの」である必要がある。

勘どころ18
テーブルとは、共通点を持ったレコードの集合である。

「テーブルとは同じ種類の物の集合である」とも言える。
「テーブル名はすべて複数形または複数名詞で書ける」と表現する。

勘どころ19
テーブル名は英語ならば複数形/複数名詞で書ける。
そうでなければそのテーブルはどこかに間違いがある。

テーブルというのは、形だけ二次元表を満たしていれば良い、というものではなく、
それ自身が現実世界と結びついた意味を持っていなければならない。


3-2
テーブルの構成要素

行と列
通常の表と同様に、テーブルにおいても横と縦のデータの組みを「行」と「列」と呼ぶ。
あるいは「レコード」と「カラム」という呼び方もする。
列（カラム） 行（レコード）


キー
表になくて（も良くて）、リレーショナルデータベースのテーブルになくてはならないものがいくつかある。
そのうちの一つが「キー（key）」
何の「鍵」かというと、ある特定のデータを引き出すための鍵。
特にリレーショナルデータベースでは、
「あるレコード（1行とは限らない）を特定するための列の組み合わせ」という意味。
キーの種類も複数あるが、特に重要なのが
①主キー
②外部キー


①主キー
「主キー」、または「プライマリーキー（Primary key）」と呼ぶ。
主キーはテーブルにおいて必ず一つ存在しなければならず、かつ一つしか存在しない。
主キーとは、その値を指定すれば、必ず1行のレコードを特定できるような列の組み合わせ。
この「1行に特定する」ことを「一意に識別する」という言い方をする。
「一意」は「unique」の訳語。


勘どころ20
テーブルには重複行は存在できない。

例えば、社員を管理するテーブルには、同じ社員が二人登録されてはいけないし、
商品を登録するテーブルの場合でも同じ。
リレーショナルデータベースにおいては、どのような理由があっても重複するデータ、
すなわち重複するレコードを持つことは許されない。
入力データに重複が存在する場合でも、（新しいキーを追加するなど）重複しないよう
工夫する必要がある。


場合によっては、複数列を組み合わせなければ主キーが作れないこともある。
複数列を組み合わせて作るキーを複合キーと呼ぶ。


主キーに関連する概念として、「候補キー（candidate key）」と「スーパーキー（super key）」
と呼ばれるキーもある。
候補キーとは、主キーとして利用可能なキーが複数存在した場合、それら「候補」となるキーのことを言う。
候補キーは定義上、複数存在する。
主キーは一つのテーブルに一つしか設定できないため、候補キーのうちから一つを主キーとして選択する。

スーパーキーは、主キーに、非キー列を付加した場合のキーの組み合わせ。


②外部キー
主キーの次に重要なキーが、「外部キー（foreign key）」。
これは二つのテーブルの間の列同士で設定するもの。
外部キーの役割は、テーブルに対して一種の「制約（constraint）」を課すこと。
この制約を「参照整合性制約」と呼ぶ。


勘どころ21
外部キーは人間の親子関係と同じ。

例えば、部署テーブルの「開発」レコードが削除された場合、社員テーブルの
加藤さんや島田さんは、”親がいない子”になってしまう。
こうした”親がいない子”も合わせて削除するか、それとも削除SQL文をエラーにするか選択できる。
あわせて削除する動作を「カスケード」と呼ぶ。
更新の場合も同じで、”親がいない子”のデータを合わせて変更するか、更新SQLをエラーにするか選択できる。
常に、子のテーブルを先に削除なり変更して、後から親のテーブルを更新していれば、問題は起きない。


勘どころ22
外部キーが設定されている場合、データの削除は子から順に操作するのが吉。


「どのような列をキーとするか」
キーに使用する列は、必ず何らかのコードやIDといった表記体系のきっちり定まったデータを、
固定長文字列のデータ型に格納して使う。
これは、リレーショナルデータベースにおけるテーブルの設計の鉄則。


勘どころ23
キーとなる列には、コードやIDなど表記体系の定まった固定長文字列を用いる。


制約
外部キーの説明において「参照整合性制約」について触れたが、テーブルには、
他にもいくつかの種類の制約を付けることができる。
①NOT NULL制約
②一意制約
③CHECK制約

①NOT NULL制約
データベースを登録するとき、その値がわからないことがある。
現時点でまだ不明だからと言う場合もあれば、原理的にそこにデータの値が定まらない
場合もある。
こういう場合、リレーショナルデータベースはそのデータをNULLという扱いにすることができる。
「空欄」にすることができる。（NULL自身は、データの値ではない。）

NULLというのはSQL上で扱うにはいろいろな問題を引き起こす厄介なもの。
可能な限りデータはNULLにしない、というのがデータベース設計における大方針。
そこで、「この列は絶対にNULLにはならない」ということがわかっている列については、
NULLを禁止することができる。
この制約は、列単位で設定することができる。
NOT NULL制約が設定された列にNULLのデータを登録しようとしたり、
NULLに更新しようとしたりした場合、そのSQL文はエラーとなる。


勘どころ24
テーブル定義において、列には可能限りNOT NULL制約を付加する。

主キーとなる列には、DBMS側で暗黙にNOT NULL制約が付加される。
主キーは重複が許されないため、NULLも当然許されない。


②一意制約
一意制約は、ある列の組について一意性を求める制約。
その点で、主キーと似ているが、主キーがテーブルにつき一つしか設定できないのに対し、
一意制約は何個でも設定できる。


③CHECK制約
ある列の取りうる値の範囲を制限するための制約。
たとえば、「年齢」列についてなら「20〜65までの整数」や
「部署」列ならば、「’開発’、’人事’、’営業’のいずれかの文字列」といった具合。

テーブルと列の名前
テーブルとテーブルの物理定義における列の名前に関するルール

ルール1 名前に使える文字集合
（a）半角のアルファベッド
（b）半角の数字
（c）アンダーバー 「_」

テーブルの物理的な定義において日本語を使って良いわけではないので、注意が必要。


勘どころ25
テーブルや列の名前に日本語はご法度。


ルール2 最初はアルファベッド
名前の先頭をアルファベッド以外で初めてはいけない。


ルール3 名前は重複してはならない
同じ名前を持つテーブル、同じ名前を持つ列は存在してはならない。
（もし作ろうとしても、エラーになる。）
列の場合は、同じテーブルの中で同じ名前を二つの列に使うことはできない。
一方、テーブルの場合は、DBMSが設定する範囲内においては、同じ名前を使うことができない。
この範囲をドメインと呼ぶ。DBMSによってスキーマと呼ぶこともある。
逆にいうとこの範囲をまたがっていれば、同じ名前のテーブルを作ることも可能。



3-3
正規化とは何か？
論理設計とは、データの形式、すなわちテーブルのレイアウトを決める設計であると言える。
論理設計において、特に理解を深めておくべき概念が
「正規化（normalization）」およびそれによって作られる「正規形（normal form）」。


正規形の定義
正規形とは、一言で言うと、データベースで保持するデータの冗長性を排除し、一貫性と効率性を
保持するためのデータ形式。
正規化には何段階かレベルがあって、一般的には第1〜第5正規形がよく知られている。
数字が増えるほど正規化のレベル（次数）が上がっていくことを意味している。


勘どころ26
正規形のレベルは第5まであるが、普通は第3正規形まで理解すれば十分。



3-4
第1正規形

リレーショナルデータベースのテーブルは、いずれもすでに第1正規形を満たす形になっている。


第1正規形の定義〜スカラ値の原則
第1正規形の定義とは「一つのセルの中には一つの値しか含まない」
このように、一つのセルに一つだけの値が含まれているとき、この値のことを
「スカラ値（scalar value）」と呼ぶ。sucalarは「単一の」と言う意味の英単語。


第1正規形を作ろう

勘どころ27
（主）キーは一部であってもNULLを含んではならない。


なぜ一つのセルに複数の値を入れてはダメなのか？〜関数従属性〜
なぜ一つのセルに複数の値を入れることがリレーショナルデータベースでは認められないか、
その理由を極端に言うと、セルに複数の値を許せば、主キーが各列の値を一意に決定できないから。
これは主キーの定義に反している。
一方スカラ値だけのテーブルならば、主キーは、各列を一意に決めることができる。
したがって、リレーショナルデータベースは、必ず第一正規形（スカラ値だけから構成されるテーブル）
を満たすテーブルだけから作らなければならない。

これは、正規形全体を理解するための鍵になる概念と結びついている。
それを、関数従属性（fuctional dependency）と呼ぶ。
正規化は、テーブルのすべての列が、関数従属性を満たすように整理していくこと。



3-5
第2正規形〜部分関数従属〜
主キーの一部の列に対して従属する列がある場合、この関係を部分関数従属と呼ぶ。
これに対して、主キーを構成するすべての列に従属性がある場合を、
完全関数従属と呼ぶ。第2正規形とは、テーブル内で部分関数従属を解消し、
完全関数従属のみのテーブルを作る。


勘どころ28
第2正規形は、部分関数従属を解消することで得られる。


第2正規化を行う
部分関数従属を解消する手段も決まっていて、その方法はテーブルの分割をする。


第2正規形でないと何が悪いのか？
第2正規化というのは、言ってみれば「会社」と「社員」という、それぞれに異なるレベルの実体（エンティティ）を、
きちんとテーブルとしても分離してやる作業だ、という見方もできる。
現実の世界では、会社があってその下に社員が存在しているわけだから、その会社という実体と社員という実体を
リレーショナルデータベースの世界でも異なるテーブルとして表現する、というのは自然な発想だとも言える。


勘どころ29
正規化とは、現実世界の実体間にある階層の差を反映する手段でもある。


無損失分解と情報の保存
第2正規化は、必ず正規化する前の状態にテーブルを戻すことができるようになっている。
こういう操作を「可逆的（reversible）」と呼ぶが、第2正規化は可逆的な操作。
第2正規化に可逆性があるのは、正規化によって失われる情報がないから。
このように情報を完全に保存したままテーブルを分解する操作のことを、
無損失分解と呼ぶ。

非正規形 ↔️ 正規形


正規化されたテーブルから、非正規化状態のテーブルへどうやって戻すのか？
その方法が、結合。

「社員」テーブルと「会社」テーブルを内部結合し、結合キーとして会社コードを使っている。


勘どころ30
正規化の逆操作は結合。


3-6
第3正規形〜推移的関数従属〜
テーブル内部に存在する段階的な従属関係のことを、推移的関数従属と呼ぶ。


第3正規化を行う
推移的関数従属によるデータ登録時の不都合を解消するには、
第2正規化のときと同じように、テーブルを分割することで、
それぞれの関数従属の関係を独立させる。

この第3正規化も、社員と部署という、これまたレベルの異なる実体を異なる
テーブルとして切り分けてやる作業として見れば、第2正規形と同じ意味を持っている。
第3正規化も無損失分解。SQL文によって、第3正規化を行う前の状態にテーブルを戻すことができる。



3-7
ボイスーコッド正規形
第3を超える正規形のことを「高次正規形」と呼ぶ。

3次と4次の狭間
正規形において、3次のすぐ上位に位置するのが、ボイスーコッド正規形。
BCNF（Boyce-Codd normal form）という略名でも呼ばれる。

この正規形はある意味で第3正規形をより厳密にしたものと考えられるから。
そのため、ボイスーコッド正規形は、非公式にですが「第3.5正規形」とも呼ばれる。

ボイスーコッド正規形でないと、更新時に次のような問題が発生する。
問題1
チーム補佐が担当チームを変える場合に複数行の更新が発生する
（データの冗長性）

問題2
社員がチームに参加するまで、チーム補佐とチームの関連を登録できない。

問題3
社員がチームから外れたときにレコードを削除すると、チーム補佐と
チームの関連も削除される危険がある。

こうした不整合を解消する方法が、ボイスーコッド正規形。


勘どころ31
ボイスーコッド正規形への分解時には気をつけないと非可逆な分解を行なってしまうことがある。

この原因は、「チームコード」をキーにした結合が、「多対多」の関連になってしまったから。
正規化は常に「1対多」の関連を生むようにテーブルを分割する必要がある。

ボイスーコッド正規化を行う
ボイスーコッド正規形というのは、なかなか難しい問題を含んだ正規形



3-8
第4正規形
「社員」や「チーム」といったエンティティ同士の関連を表現するエンティティを、
文字通り「関連エンティティ」と呼ぶ。
第4正規形及び第5正規形は、この関連エンティティに対して発生するもので、
第3正規形までで考えてきたような、「社員」や「会社」といった
具体的な実体を伴ったエンティティの正規化は発生しない。


多値従属性〜キーと集合の対応〜
キーと集合との対応を多値従属性と呼ぶ。


第4正規化を行う
第4正規形は、独立な多値従属性が複数存在するテーブルを分割することで作られる。


第4正規形の意義
この第4正規形は、ある意味で「自然な」正規形。
複数の多値従属性を一つのテーブルで表現しようとするのは、
正味な話、かなり無理のある設計だから。
「関連エンティティを作る場合は、そこに含まれる関連は、一つだけにすること」
という設計上のルールが必要だ、ということ。


勘どころ32
関連エンティティに含まれる関連は一つだけにすること。



3-9
第5正規形
第5正規形は第4正規形をもう少し発展させたもの。

第5正規化を行う
「一つの関連につき一つのテーブル」という対応でテーブルを作れば良いので、
第5正規形を満たすために必要な設計上のルールは、
「関連がある場合は、それに対応する関連エンティティを作ること」というもの。
関連と関連エンティティは一対一に対応させろ、ということ。
このルールを守っていれば自然と第5正規形になる。


3-10
正規化についてのまとめ

正規化の三つのポイント
ポイント1 正規化とは更新時の不都合/不整合を排除するために行う
正規化を行う目的は、何よりも更新（データ登録=INSERTも含む）時の不都合を防ぐためのもの。
また、データの冗長性を排除して、人間のオペレーションミスによるデータの不整合を防ぐ目的もある。

ポイント2 正規化は従属性を見抜くことで可能になる
正規化を行うためには、テーブル内部の従属性の関係を見抜く必要がある。
部分関数従属（第2正規形）、推移的関数従属（第3正規形）が存在していれば、
まず正規化の対象になる。また、多値従属性が存在していたら
自分が第4正規形に反する設計をしていないか注意する。
どの列がどのキーに従属しているか、ということは業務ロジック（ビジネスツール）で
決まることなので、各列がどの業務上どのような意味と関係を持っているか、
ということを調べなければならない。（業務分析の必要性）

ポイント3 正規形はいつでも非正規形に戻せる
正規化によって分割されたテーブルは、いつでも非正規化テーブルに復元することができる。
これは正規化が情報を完全に保存する無損失分解だから。
そしてこのことが示すのは、高次の正規形は、低次の正規形を含んでいる、ということ。


正規化は常にするべきか？
・第3正規形までは、原則として行う。
・関連エンティティが存在する場合は関連エンティティが1対1に対応するよう注意する。

正規化を行えば行うほど、利点がある
利点1
データの冗長性が排除され、更新時の不整合を防止できる。

利点2
テーブルの持つ意味が明確になり、開発者が理解しやすい。

データベースの第一目的はデータを整合的な状態で保持することにあるため、
何よりもデータ不整合を防止することに主眼が置かれる。
正規化はそのために考え出された方法論。

欠点
テーブルの数が増えるため、SQL文で結合を多用することになり、
パフォーマンスが悪化する。

欠点は無視できないため、パフォーマンス向上のため、あえて正規形を
低次なものにとどめる設計が採用されることはある。


演習問題
演習3-1 正規形の次数
テーブルの正規形の次数を答える
第1正規形

演習3-2 関数従属性
「支社支店商品」テーブルの関数従属性を挙げる
部分関数従属
{支社コード}→{支社名}
{支社コード、支店コード}→{支店名}
{商品コード}→{商品名、商品分類コード}

推移的関数従属
{商品コード}→{商品分類コード}→{分類名}

演習3-3 正規化
「支社支店商品」テーブルを可能な限り、高次に正規化する。
三つの部分関数従属を解消するために、三つのテーブルを作る。
解答例を参考



第4章
ER図〜複数のテーブルの関係を表現する〜

エンティティ（テーブル）の数が増えると、相互の関連を効率的に把握するための手段が必要になる。
それがER図。ER図の描き方には様々な「流派」がある。
IE表記法とIDEFIXによる記述方法を学ぶ。

・テーブル（エンティティ）の数が増えていくと、テーブル同士の関係がわかりにくくなり、
設計に支障をきたす。この問題を解決するため、テーブル同士の関係を記述する道具がER図。

・ER図の描き方には何種類かフォーマットがある。
代表的なIDEFIXとIE表記法を学習する。

・リレーショナルデータベースにおけるテーブル間の関係は、基本的に「1対多」
「多対多」の関係は、「1対多」の関連に分解する。

・「多対多」を「1対多」に分解するときに必要になるエンティティを「関連実体」と呼ぶ。


4-1 テーブルが多すぎる
正規化によってテーブルを整理していくと、どんどんテーブルの数が増えていく。
そのままの状態で管理することは、人間にはできない作業。
こうした多数のテーブルを管理するために、それぞれのテーブルがどういう意味を持っていて、
テーブル同士が互いにどういう関係にあるのか、ということを明示するために作る図を
ER図（Entity-Relationship Diagram : 実体関連図）と呼ぶ。
E（Entity:実体）とはテーブルのこと、R（Relationsip:関連）は文字通りテーブル同士の関連のこと。

ER図の書き方にはいくつか「流派」があるが、
代表的なフォーマットを覚えておけば、大体の場合には対応できる。
その二つが、IE（Information Engineering）表記法とIDEFIX。
IE表記法は通称「鳥の足」という名前でも知られていて、
直感的にテーブル間の関連を理解しやすいため、初心者向けの記法。


4-2 テーブル同士の関連を見抜く
ER図を描くとき、最初に着目するポイントは、あるテーブルの主キーが、
他のテーブルに列として含まれているかどうか、という点。
もしその場合、二つのテーブルの間には意味的な関連があることになるから。


1対1、1対多、多対多
同じ意味の列を持っているテーブル同士の間では、一般に次の3パターンの関連がありえる。

パターン1 1対1
パターン2 1対多
パターン3 多対多

「1対1」というのは、あまり見かけない。二つのテーブルのレコードが1対1に対応するということは、
要するに二つのテーブルの主キーが一致するケースであり、そうであれば普通は一つのテーブルに
まとめてしまっても問題ないから。少なくとも、正規化の過程でこのような1対1のテーブルが作られることはない。

「1対多」は、最もよくある関連のタイプ。基本的に正規化によって生まれる関連はこのカテゴリーに属す。
「1対多」と「0または1対多」に分かれるが、一般的にはこの二つのサブカテゴリをまとめて「1対多」と呼ぶことが多い。
「多」の側についても、「0以上」「1以上」の場合があるが、こうした細かい区別についても、ER図で表記することが可能。

「多対多」は少し特殊なカテゴリ。
最初に業務要件からテーブルを作っていくと、この多対多の関連を持ったテーブル群ができあがることがある。
リレーショナルデータベースのお約束として、この多対多の関連は作ってはならない、ということになっている。

4-3
ER図の描き方

テーブル（エンティティ）の表記方法
ER図でのテーブルの表現方法ですが、これはIDEFIXもIE表記法も同じ。

四角の中を横線で二つのスペースに区切っているが、上のスペースは主キー属性、
下のスペースは非キー属性を記述する場所。
（非キー属性は、数が多い場合は代表的なものだけを記述する。）
他のテーブルの主キーを参照する外部キー（foreign key）については、
属性名のとなりに略称の「FK」を記述する。


IE表記法でER図を描く
「会社」エンティティの側についている横棒（-）は相手のエンティティと
対応するレコード数（これをカーディナリティと呼ぶ）が1であることを示してる。
一方、「社員」テーブル側の「⚪︎」「↑」はそれぞれ、
カーディナリティが「0」及び「複数」を意味する。
つまりこの二つを合わせて「0以上の複数」と言う意味になる。
IE表記法が鳥の足と呼ばれるのは、複数を表す「↑」に由来している。


勘どころ33
IE表記法のカーディナリティの記号は
⚪︎ : 0
- : 1
↑ : 多（2以上）

基本的に三つを組み合わせることで、先ほどの例のような複雑だカーディナリティの
パターンを表現することができる。


IDEF1XでER図を描く
IE表記法と大きく違うのは、エンティティの表現として、角の尖った四角と角の丸い四角の二つに分かれる。
角の尖った四角で表記したエンティティである会社および部署は、独立エンティティであることを意味する。
これは、他のテーブルに依存することなく、データを保持することのできるエンティティ。

一方、角の丸い四角で表記したエンティティである社員は、従属エンティティ（または依存エンティティ）
であることを意味している。
これは、他のテーブルにデータが存在しなければ、データを保持することのできないエンティティということ。
このエンティティの特徴は、主キーに他テーブルを参照する外部キーを含むこと。

逆に、主キーに外部キーを含んでいなければ独立エンティティなので、
この区別は機械的に行うことができる。


勘どころ34
独立エンティティと従属エンティティの区別は主キーに外部キーが含まれているかでわかる。

カーディナリティの記述パターンには、次のような種類がある。
0以上  ⚫︎
1以上  ⚫︎P
0または1  ⚫︎Z
n（特定の定数）  ⚫︎n

IDEF1Xでは、「1対多」のうち、「1」の側のエンティティについては、黒丸は使わないと決められている。
黒丸を必ず「多」の側にだけ付けることで、どちらが「1」でどちらが「多」であるかを一目でわかるようにしている。


勘どころ35
IDEF1Xでは、黒丸（⚫️）がIE表記法の「鳥の足」にほぼ近い意味を持つ。

そのため、「1対多」の「1」の側である会社については、黒丸をつけずにただの棒線を引くことで
カーディナリティが「1」であることを表現している。
注意すべきは、部署テーブル側についている「◇」は、
同じカーディナリティ「1」であっても、部署コードがNULLでありうることで、
社員から部署が一つに決まらない可能性があることを示している。

また、会社と社員を結ぶ関連の線が実践であるのに対し、部署と社員を結ぶ線が点線であるのも、
この外部キーにNULLを許すか否かによっている。

会社と社員のように、社員が会社に必ず属さなければならない場合、これを依存リレーションシップと呼んで、
実線で表す。
一方、社員と部署のように、必ずしも社員が部署に所属していなくてもいい場合、これを非依存リレーションシップと
呼んで、点線で表す。先ほどの依存エンティティと独立エンティティの関係にも対応している。


4-4
「多対多」と関連実体
現実世界に存在するエンティティを、リレーショナルデータベース内のER図として記述しようとすると、
多対多の関連を持ったエンティティができることは、珍しいことではない。


「多対多」がリレーショナルデータベースの世界ににおいて問題となる理由は、両者のエンティティが
共有のキーとなる列を保持していないため、両エンティティを結合した情報を得ることです。
もし、多対多のエンティティ同士を無理矢理にでも関連づけようとすれば、
「学生」テーブルに「講義コード」列を持つようにするしかない。

多対多エンティティの問題は、「学生」と「講義」の二つのエンティティだけを前提としている限り、
解決不可能。
この問題を解決するための方法が、関連実体（associative entity）。
二つのエンティティの間に第3のエンティティを作成する。


演習4-1 ER図
5つのテーブルのER図を作成する
draw.ioにて作成

「支社」と「支店」の間には、「支社は複数の視点を統括する」という1対多の関係が成立する。



演習4-2 関連エンティティ
関連エンティティはどれか？
支店商品

「支店」エンティティと「商品」エンティティは、多対多の関連を持っている。
一つの支店は複数の商品を扱うし、一つの商品は複数の支店で売られているから。


演習4-3 多対多の関連
・消費者-商品
消費者は、一人が複数の商品を買うことができる。また、一つの商品は複数の消費者に買われるので、多対多の関連になる。
これを解消するための関連実体は、「購入」または「注文」

・学生-部活
学生は一人が複数の部活を掛け持ちできる。また、一つの部活には複数の学生が所属する。
これを解消するための関連実体は「所属」

・著者-書籍
著者は、一人が複数の書籍をかくことができる。書籍も、複数の著者（共著）をもつことができる。
これを解消するための関連実体は「著述」



第5章
論理設計とパフォーマンス〜正規化の欠点と非正規化〜

正規化はデータベース設計における基本。しかし、正規化されたテーブルは、
往々にして現場のDBエンジニアからは評判が良くない。
それは、正規化がパフォーマンス上の深刻な問題を引き起こしてしまうから。


学習のポイント
・正規化することは、データベースにおけるテーブル設計の基本。
しかし、厳格に正規化すると、時として正規化の欠点が現れることがある。
その最大の欠点は、SQLパフォーマンス問題。

・正規化がSQLのパフォーマンス問題を引き起こすのは、
正規化するとSQL文の中で結合（join）が必要になるから。
結合は、SQLの処理の中でも高コストなため、多用するとSQLの速度が悪化する。

・この問題に対処する方法は二つ。一つは、SQL文そのものに対するチューニング。
もう一つは、非正規化。

・正規化以外にもSQLパフォーマンスを悪化させるテーブル設計がある。
それもまた正規化と同様、過度に冗長性を排した結果生じるもの。
そうした場合には、あえて冗長なデータを保持する設計が有効になる。


5-1 正規化の功罪
正規化とSQL（検索）
正規化されたテーブルは、単独のテーブルでは必ずしもユーザーが欲する全ての情報をカバーできない。
これは、正規化が、ある意味で、情報を複数のテーブルに分散させる行為だから。

正規化されたテーブル群であっても、SQL文で結合を使うことによって、
得たい結果を自由に得ることができる。
これは、正規化が無損失分解、つまり情報を一切失わない作業であるから。
他方でSQLにおける結合は非常にコストの高い作業であり、結合するテーブル数、
およびテーブルのレコード数が増えれば増えるほど処理時間がかかる
正規化することでシステムパフォーマンスが劣化する原因の多くが、このSQLの結合操作にある。

非正規化による解決
結合によらず解く方法は、正規化を捨てること（非正規化）。

勘どころ36
非正規化テーブルならば、SQLで結合を使わずに済む。


正規化とSQL（更新）
正規化（非正規化）と更新処理の関係はどのようなものになるか。
このケースは正規化のほうに軍配が上がる。


正規化と非正規化、どちらが正解なのか？
正規化は必須であり、いかなる理由があろうとも非正規化するべきではない、
という原理的主義な立場から、最初から非正規化を論理設計の中に織り込む
「現実主義的」な立場まで、正規化に対する態度は人により様々。
それだけ、正規化と検索SQLのパフォーマンスは強いトレードオフの関係にあるということ。
厳しく正規化すればパフォーマンスが悪化し、パフォーマンスを求めて非正規化すれば、
データ不整合が発生しやすくなる。

正規化の次数が低いほど検索SQLのパフォーマンスは良いが、
データ整合性は低く、正規化していくほどパフォーマンスが低下する代わりに
データ整合性が高くなる。

「非正規化は最後の手段」--逆に言うと、最初は必ず正規化するのだ、ということ。
正規化の次数は高ければ高いほど設計という観点からは望ましい。





5-2 非正規化とパフォーマンス
サマリーデータの冗長性とパフォーマンス
正規化、すなわち冗長性排除によって引き起こされる性能問題には、SQLの構文という観点から見ると、
大きく２種類のパターンに分けられる。
一つ目が、サマリーデータの冗長性排除によるパターン。
もう一つが、選択条件の冗長性排除によるパターン。
両方とも1対多の関連を持つ二つのテーブル間で発生する。


結合しないSQLを作るためのテーブル設計
「注文」というエンティティに「商品数」というサマリーデータ（集計データ）を持つことは、
冗長性をもたせた設計の一種と言える。事実、「受注」テーブルへのこのような変更は、
非正規化でもあるから。「商品数」列は、「受注日」という非キー列に従属している。

このような推移的関数従属があることから、この「受注」テーブルは第3正規形ではなくなる。
そのトレードオフとして検索処理が非常に簡単でハイパフォーマンスなものになる。

勘どころ37
サマリーデータを冗長に保持すると正規形に違反するが、検索を高速化できる。


選択条件の冗長性とパフォーマンス
選択条件を冗長にすると第2正規形ではなくなる
変更後「受注明細」テーブルは、先ほどのサマリーデータを追加した場合の
「受注」テーブルと同じく、正規形に違反する。
というのも、主キーの一部である「受注ID」から非キー列である「受注日」への部分関数従属が
生まれてしまうから。


勘どころ38
選択条件を冗長に保持すると正規形に違反するが、検索を高速化できる。


正規化は、可能な限り高次にすることが大原則
しかし、それでもなお実務における論理設計では、性能のために非正規化が必要になる時がある。
いかにSQLのパーフォーマンスチューニングを行おうとも、
テーブル構成が正規化された状態では限界があるから。
データ構成がプログラムのコードを決定するのであって、その逆ではない。

非正規化は、様々なトレードオフを考慮しながら身長に実施する必要のある、難しい仕事。


5-3 冗長性とパフォーマンスのトレードオフ

非正規化が更新不整合のリスクを増やす。
リスク1
非正規化は、検索のパフォーマンスは向上させるのが更新のパフォーマンスを低下させる。

リスク2
データのリアルタイム性（鮮度）を低下させる

リスク3
後続の工程で設計変更すると、手戻りが大きい。


更新時のパフォーマンス
データのリアルタイム性
反映周期が短ければ短いほど、システムへかかる負荷は高くなり、性能問題も起きやすくなる。
ユーザーからは短ければ短いほど嬉しい。
両者のバランスが取れる平均点を見つけ出さなければならない。


改修コストの大きさ
システムの改修コストの大きさ。
データモデルの変更は、コードベースの修正に比べて、非常に改修コストが大きくなる。
これはデータのフォーマットがプログラムを決めるDOAの大原則。
性能試験をやって性能が出なかったので、やっぱりテーブル構成を変更したい、
と言っても、アプリケーションを大きく改修しなければならない、という理由で
なかなか受け入れてもらえない。

論理設計をする際には、「システムの品質は（ひいては開発が成功するかどうかは）今ここで決まる！」という気概を
持って臨む必要がある。


勘どころ39
残念なことに、論理設計には物理設計の知識が必要である。



演習問題
演習5-1
正規化されたテーブルに対するSQL
SQL文1 商品分類ごとの商品数。結果には分類名を含むものとする。

SELECT 商品分類.商品分類コード,
       商品分類.分類名,
       COUNT(*) AS 商品名
FROM 商品分類 INNER JOIN 商品
ON 商品分類.商品分類コード = 商品.商品分類コード
GROUP BY 商品分類コード,商品分類.分類名;

複数のテーブルを結合するような複雑なSQLを考える時のコツは、
「FROM」から考える。このSQLを書くために必要なテーブルはなんだろうと考えること。
FROM、WHERE、GROUP BYという順序で考える。
商品分類名が必要とされることから「商品分類」テーブルが必要。
次に、商品の個数を数える必要があることから「商品」テーブルも必要。
この二社がFEOM区で必要になるテーブル。


SQL文2 支社/支店別の取り扱い商品の一覧。結果には支社名、支店名、商品名を含む。
SELECT 支社.支店名,
       支店.支店名,
       商品.商品名
FROM 支社 INNER JOIN 支店
       ON 支社.支社コード = 支店.支社コード
       INNER JOIN 支店商品
       ON 支店.支社コード = 支店商品.支社コード
       AND 支店.支店コード = 支店商品.支店コード
       INNER JOIN 商品
       ON 支店商品.商品コード = 商品.商品コード;

先ほどと同様に、FROM句から考えていきましょう。まず、結果に必要な例として、
「支社名」「支店名」「商品名」が指定される。このことから、
それぞれの例を保持している「支社」「支店」「商品」三つのテーブルが必要なことがわかる。
それ以外にも、各支店別の商品の取り扱いを知るには、関連エンティティである「支店商品」テーブルが必要。


SQL文3 最も取り扱い商品数が多い支店の支店コードと商品数。
SELECT 支店.支社コード,
       支店.支店コード,
       COUNT(*) AS 最大商品数
FROM 支店 INNER JOIN 支店商品
ON 支店.支社コード = 支店商品.支社コード
AND 支店.支店コード = 支店商品.支店コード
GROUP BY 支店.支社コード, 支店.支店コード
HAVING COUNT(*) >=
        (SELECT MAX(商品数)
          FROM(SELECT 支社コード,
                      支店コード,
                      COUNT(*) AS 商品数
                      FROM 支店 INNER JOIN 支店商品
                      ON 支店.支社コード = 支店商品.支社コード
                      AND 支店.支店コード = 支店商品.支店コード
                      GROUP BY 支店.支社コード, 支店.支店コード)TMP);

HAVINGよりもあとのサブクエリでは、取り扱い商品が最も多い支社の商品数を選択している。
HAVING句よりも前のパートで、その最大商品数を持つ支店を選択している。



演習5-2 非正規化によるSQLチューニング
演習5-1の回答のSQLに対して、パフォーマンス向上を実施する。
非正規化を含むテーブル構成の変更による方法を考える。


第6章
データベースとパフォーマンス

データベース設計というと、論理設計にのみ目を奪われがちだが、それでは十分なパフォーマンスを確保するには不十分。
データベースにおけるパフォーマンスの設計は、DBMSの内部アーキテクチャに踏み込む物理レベルの知識が必要になる。
インデックスと統計情報という二つの観点を通して、ハイパフォーマンスを実現する方法を考える。

・データベースのパフォーマンスを決める主な要因は、ディスクI/Oの分散（RAID）、
SQLにおける結合（正規化）、そしてインデックスと統計情報。

・インデックスにはいくつかの種類があり、まずはB-trreインデックスを覚えておくことで多くのケースに対処できる。

・インデックスはパフォーマンス向上に有効な道具だが、正しい使い方をしなければ効果を発揮しない。

・統計情報はDBMSにとっての地図情報。これが最新でなければ、DBMSは最短のアクセスパスを選択できない。

・DBMSも人間の作ったものなので、最新の地図を見ても道を間違えることもある。


6-1
データベースパフォーマンスを決める要因

インデックス
インデックスは、SQLチューニングの手段として非常にポピュラーで、これを利用しないシステムはない、
というぐらいよく使う。
インデックスとは、プログラミング言語的な表現をすると（x,a）という形式の配列。

xはキー値、aはそれぞれに結びつく情報 （実データか、あるいはそれへのポインタ） を意味する。
データベースにおいてaはデータへのポインタであることが多い。


統計情報
統計情報が重要な理由は、これがSQLのアクセスパスを決める最大の要因だから。
DBMSは、ユーザーからSQLを受け取ると、どのような経由（パス）でデータを探しにいくのが最も有効的か、
自分で判断する。
SQLには、「こんなデータが欲しい」という条件は記述されていても、「こうやってデータを取りに行け」という
方法までは書かれていない。その方法を多くの選択肢の中から見つけ出すのは、DBMSの仕事。





6-2
インデックス設計
インデックスはSQLのパフォーマンス改善のための非常にポピュラーな手段。その理由は
①アプリケーションのコードに影響を与えない。（アプリケーション透過的）
②テーブルのデータに影響を与えない。（データ透過的）
③それでいて性能改善の効果が大きい。


①アプリケーション透過的
インデックスを使うかどうかは、DBMSが自動的に判断する。
インデックスを使う場合、単純にデータベース側にインデックスを作成すれば良いだけで、
アプリケーションプログラムの変更が必要ない。
「存在を意識しなくても良い」という性質を「透過性（transparency）」と呼ぶ。
もとは透明という意味で、空気のように透明でその存在を意識しなくて良い、というニュアンス。
アプリケーションから見れば、インデックスは空気のように透明。


②データ透過的
インデックスは、データ透過的でもある。インデックスを作成することでテーブルに格納されている
データの中身が影響を受けることがないし、テーブルの構造も変化することはない。
インデックスを作成する際に論理設計を修正するような手戻りを心配する必要はない。


③大きな性能改善効果
インデックスのもたらす性能改善の効果は、しばしば劇的。
インデックスの性能が、データ量に対して線形よりも緩くしか劣化しないため。
インデックスによる性能改善は、多くの場合にデメリットをメリットが大きく上回る形で成果が出る。
インデックスをやみくもに作っても、効果が出るわけではない。
正しい指針を理解したうえで使って初めて効果が得られる。



B-treeインデックスから
一口にインデックスと言っても、いくつかの種類があり、またDBMSによっても使用できる
種類に差がある。実は頻繁に利用するインデックスは1種類しかないため、基本的には一つを覚えて
おけば十分。そのインデックスがB-treeインデックス。
この他にもビットマップインデックス、ハッシュインデックスなどがあるが、使うのはまれ。
B-treeは、非常にポピュラーであるため、通常DBMSにおいて何のオプションもつけずに
インデックスを作成すると、暗黙にB-treeインデックスが作成されるくらい。


勘どころ40
インデックスにはいろいろあるが、まずはB-treeインデックスを覚えておくこと。


B-treeインデックスの長所
B-treeインデックスのパフォーマンスが非常に優れている、というわけではない。
場合によっては他のタイプのインデックスの方が優れていることもあるという。
B-treeの長所は、平均点の高さ。B-treeを「幅広い名手」と呼び、
事実、B-treeをレーダーチャートで評価するとオール4の秀才型になる。

その他のインデックスにはない特徴。他のタイプのインデックスは、いずれも
一長一短のものが多く、汎用性い欠ける。B-treeは、どの科目でも一番にはなれないが、
総合評価で1位を勝ち取るタイプ。


勘どころ41
B-treeインデックスはオール4の秀才。


B-treeインデックスの構造
なぜB-treeが秀才型なのか？
B-treeは、「木」という名前のとおり、木構造でデータを保持する。
最下層のリーフ（葉）と呼ばれるノードだけが、実データに対するポインタを保持していて、
データベースは、最上位のノード（ルート）から順にノードをたどって、リーフから実データを見つけにいく。


①均一性
B-treeは平衡木（balanced tree）であるため。平衡木とは、どのリーフもルートからの距離（高さ）が
一定の木のことを指す。これによって、どんなキー値を使っても、常にリーフまでの距離が一定になるため、
検索を同じ計算量で行える。

B-treeは、最初に作られたときは、きれいな平衡木だが、テーブルへの挿入、更新、削除などが
繰り返されることによって、インデックスの構造も崩れていき、非平衡木になっていくことがある。
B-treeは、極力このようなバランスの崩れを起こさないよう、自動的に修復する機能も備わっているが、
それでも長期間の運用によって更新が重なれば、木のバランスは悪くなり、探索にかかるコストもばらつきが出る。


②持続性
「B-treeといえども更新が繰り返されることによって性能劣化は発生する」と述べた。しかし、それでもなお、
B-treeの性能劣化は長期的に見ても、非常に穏やか。この「穏やか」をもう少し正確にいうと、
テーブルのデータ量が増えても、B-treeの検索や更新にかかる時間はほとんど増えない。
厳密には、データ量の対数に比例して増える。

B-treeインデックスがデータ量に対して穏やかにしか性能が劣化しないのは、
「平べったい（broad）」木だから。背が低い木であることは、データ量が膨大に増えたとしても変わらない特性。


③処理汎用性
B-treeインデックスは、挿入、更新、削除のコストも、検索と同じくデータ量nに対してO（log n）。
いずれの処理も同じくらいの探索速度となり、かつデータ量が増えても性能劣化の度合いが緩やか。


④非等値性
B-treeは、等号（=）による検索のみならず、不等号（<,>,<=,>=）やBETWEENといった範囲検索の条件に対しても、
高速化を可能とする。
B-treeは、構築されるとき必ずキー値をソートするため、たとえリーフノードを一つに絞れないとしても、
特定のノードよりも、「左」とか「右」のノードだけに探索範囲を絞ることが可能になるから。
B-treeが効果を持たない検索条件は、否定条件（<>,!=）。これは、特定のノード以外のすべてののノードが該当して
しまうので、B-treeによる絞り込みが効かず、まったく役に立たない。


⑤親ソート性
SQLは一切の手続きを記述しないため、SELECT文やUPDATE文の中でも明示的にソートを記述することがない。
次のような処理を記述したときには、暗黙にDBMS内部でソートが行われている。
・集約関数（COUNT,SUM,AVG,MAX,MIN）
・ORDER BY句
・集合演算（UNION,INTERSECT,EXCEPT）
・OLAP関数（RANK,ROW_NUMBERなど）

ソートは、かなりコストの高い演算。ソートはDBMS内部で専用のメモリ領域が割り当てられていて、
その内部に一時的にデータを保持して実施される。
大量データのソートが必要な場合、メモリに載りきらないためにあふれてしまうことがある。
SQL文を記述する際は、極力大きなソートを避けることがパフォーマンス上は望ましい、ということになる。

B-treeインデックスは、先述のように構築時にキー値をソートして保持する。
B-treeインデックスが存在する列をORDER BY句のキーとして指定した場合、
ソート処理をスキップすることが可能になる。
データベースのパフォーマンスにとって鬼門の一つであるソート処理をチューニングする大きな助けになる。



6-3
B-treeインデックスの設計方針

B-treeのインデックスはどの列に作れば良いか？
B-treeインデックスは、やみくもに作れば良いわけではなく、いくつかの方針がある。

方針1 大規模なテーブルに対して作成する。
方針2 カーディナリティの高い列に作成する。
方針3 SQL文でWHERE句の選択条件、または結合条件に使用されている列に作成する。


B-treeインデックスとテーブルの規模
B-treeインデックスの特性「持続性」について解説したときの、データ量と処理時間のグラフを確認すると、
データ量が少ない場合、B-treeインデックスを使うよりもフルスキャンに任せた方が高速な領域がある。
この領域における処理時間の差はごくわずかであるため、B-treeでもフルスキャンでも大差はない。
それであればわざわざ無駄なインデックスを作る必要はない。
目安としてはレコード数が1万件以下の場合はほぼ効果がないと考えられる。


勘どころ42
データ量が少ない場合はインデックスの効果はない。


B-treeインデックスとカーディナリティ
B-treeインデックスを作成する例として不適切を判断するための最も重要な情報が、カーディナリティ。
特定の列の値が、どのぐらいの種類の多さを持つか、ということを表す概念。
B-treeインデックスを作るときは、カーディナリティの高い列を選ぶことが基本。
この場合の目安は、特定キー値を指定したときに、全体レコード数の5%程度に絞り込めるだけの
カーディナリティがあること。


カーディナリティの注意点
一つ目は、複合列に対してインデックスを作成する場合、カーディナリティは
対象の複合列の組み合わせで考える、ということ。
（a,b,c）という列にインデックスを作成するとして、カーディナリティがそれぞれ
aは2、bは10、cは5だとする。この場合、どの一列をとっても、絞り込みの率は5%より大きくなる。
しかし、（a,b,c）という組み合わせで見た場合のカーディナリティが100だとすれば、
絞り込みの率は1%となり、B-treeインデックスは十分に有効性を発揮する。
二つ目は、たとえカーディナリティーが高くても、特定の値にデータが集中しているような列は向いていない。
たとえば、1~100までの値を取る列があったとする。この列のカーディナリティは100。
ところが、値の99%が100で、1~99の値は全体の1%しか取らない、というようなケースでは
B-treeによる検索性能は安定しない。これは、100を指定したSELECT文が非常に広範囲の検索を行わなければ
ならないのに対して、残りの1~99の値を指定したときはほぼピンポイントでヒットするから。


勘どころ43
カーディナリティが高い列ほどインデックスの効果が高い。ただし、値が平均的に分散しているのがベスト。



B-treeインデックスとSQL
SQLで検索条件や結合条件として使用されない列にいくらインデックスを作っても無意味。
インデックスが使用されるためには、SQLの記述方法としていくつか気をつけるべきポイントがある。
次のSQLhaいずれもインデックスを利用できていない。

①インデックス列に演算を行っている
インデックスを作成した列はSQLにおいて「裸」で用いるのが原則。
演算を行ってはいけない。

②索引列に対してSQL関数を適用している
理由は①と同じ

③IS NULL述語を使っている
B-treeインデックスは一般的にNULLについてはデータの値とは見なさず、保持していない。
したがって、IS NULLまたはIS NOT NULL述語に対しては有効でない。

④否定形を用いている
否定形はインデックスを利用できない。これは、たとえ利用したとしても検索範囲が広すぎて役に立たないから。

⑤ORを用いている
ORを用いた場合はインデックスが利用されない。
INで書き換えるこで回避できる。

⑥後方一致、または中間一致のLIKE述語を用いている
LIKE述語を使うときは、前方一致検索の場合のみ索引が使用される。

⑦暗黙の型変換を行なっている
データ型の異なる列値をSQLにおいて選択条件または結合条件として利用する場合、
数値型⇔文字列型、文字列型⇔日付型のように、型変換を行なって型を統一する必要がある。
通常はSQL文の中で関数を使って明示的に行うが、明示的な変換型を行わなくても、
SQL文がエラーになるわけではない。
列とデータ型の異なる値を条件に指定した場合、DBMSは内部的に暗黙の型変換を行う。
その場合はインデックスは使用されなくなる。これを回避するためには、
明示的に条件に使用する値のデータ型を列のデータ型に合わせてやる必要がある。


B-treeインデックスに関するその他の注意事項

主キーおよび一意制約の列には作成不要
DBMSは主キー制約や一意制約を作成する際、内部的にはB-treeインデックスを作成している。
B-treeインデックスがデータをソートして保持するため、重複値チェックにこれを利用している。


B-treeインデックスは更新性能を劣化させる
インデックスは一般的にテーブルとは独立のオブジェクトとしてDBMS内部に保持されている。
したがって、インデックスが作成されている対象の列値が変更されると、
インデックス内に保持している値も変更しなければならない。
B-treeインデックスを作成すればするほど、該当テーブルに対する更新性能が劣化していく。
このトレードオフにはよく注意して、極力無駄なインデックスを作成しないよう気をつける必要がある。


定期的なメンテナンスを行うことが望ましい
「均一性」と「持続性」の特性を説明したときにも述べたように、インデックスは、
テーブルのデータが更新されていくと、長期的には構造が崩れて性能が劣化していく。
運用において定期的なメンテナンスを行う、具体的にはインデックスの再構築を行うことが、
性能を維持するためには望ましい方策。


6-4
統計情報

統計情報はテーブルやインデックスなど「データ」についてのデータ、すなわち「メタデータ」。
DBMSにはこのメタデータを頼りにSQLのアクセスパスを決定する。
具体的なプロセスには、ユーザーは基本的に関わらないため、SQLがどのようなアクセスパスで実行されるか、
という問題には、ユーザーは統計情報を通してのみ関与することになる。


オプティマイザと実行計画
DBMSはSQLを受け取った後、直接データアクセスを行なっているのではなく、
何段階もの前作業を行なっている。このように、DBMSが実行計画を決める
ブラックボックス的な方法は、一見すると非効率で、どんなパスが選択されているか
見えないことを不安に思うかもしれない。しかし、実際にはデータへのアクセス方法は
非常にたくさんあるうえに、コストの計算も非常に複雑であるため、これを人間が行うほうが非効率。


勘どころ44
SQLの実行計画は、DBMSが「お任せ」で選ぶ。


統計情報の設計指針
一般的にエンジニアがSQLの実行計画立案に直接的に関与することはない。
あくまで、統計情報を通した間接的な関わり方になる。
設計においても考慮することも、統計情報の収集をどのように行うか、というポイントに絞られる。

ポイント1 統計情報収集のタイミング
ポイント2 統計情報収集の対象（範囲）

統計情報収集のタイミング
統計情報を収集すべきタイミングについての基本的指針は次の一点につきる

勘どころ45
データが大きく更新された後、なるべく早く。

「更新」には、INSERT/UPDATE/DELETEいずれも該当する。
レコード件数が増減するのはもちろんのこと、データの値の分布や偏りが変わることも、
アクセスパスの選定に影響する。
更新処理によってテーブルのデータが大きく変われば、古い統計情報と最新のテーブルの状態に齟齬が生じる。
間違った情報に基づいては、オプティマイザがどれだけ賢くても、正しい道を選ぶことはできない。

逆に言うと、データの更新量が少ない場合は、統計情報を収集する意味はあまりない。
しかも、統計情報収集というのは、それなりにリソースを消費する、長時間かかる処理でもある。
統計情報収集は、基本的にシステムの使用者が少ない夜間帯に実施することが原則。

勘どころ46
統計情報収集は原則、夜間帯に実施する。

統計情報収集の対象（範囲）
統計情報を収集する範囲は、これまでの統計情報についての説明から自ずと導かれる。
「大きな更新のあったテーブル（およびインデックス）」が対象
統計情報収集というのは、わりと負荷の高い処理でもある。
データが変更されていないテーブルまで再収集の対象に含めるのは、
収集にかかる時間を無駄に長くするだけなので、本当に必要なテーブルに限定する必要がある。


統計情報の凍結について
統計情報収集の設計の基本は、なるべくそれを最新の状態に保つこと。
オプティマイザが適切な実行計画を作るためには、地図が最新である必要があるし、
この点については、あらゆるDBMSベンダーの間で見解が一致している。
実際のシステム開発においては、あえて統計情報の収集をまったく行わない、
という選択肢が有効な場合がある。
統計情報をあえて収集せず、特定の時点の統計情報で更新を止めることを
「統計情報を凍結する」や「統計情報をロックする」と言う。
現状のものから実行計画を変化させたくない場合に凍結を行うのが望ましい。
実際に統計情報を凍結できるのは、データ量がサービス開始時と終了時でほとんど変化しない
特性を持っているシステムくらいというのが現状。


勘どころ47
統計情報の凍結は、オプティマイザを信じない悲観的設計。しかし現実に実施するのはかなり大変。

演習6-1 ビットマップインデックスとハッシュインデックス
ビットマップインデックス
ビットマップインデックスは、データの値からビットデータを作成して、それをインデックスとして保持する。
それによって、検索条件に対してもビットデータの演算で検索を行うことができる。
B-treeが苦手だったカーディナリティの低い列に対しても検索性能が良いという利点を持つ。
B-treeインデックスが有効にならない「OR」条件に対しても利用できるという利点がある。
ビットデータはとてもサイズが小さいため、インデックスそのものも小さくなる、という利点もある。

ビットマップインデックスの欠点は、テーブルのデータが更新されるたびにインデックスのビット値も更新する
処理を行わなければならないため、更新時の性能が悪い。頻繁にデータ更新が行われるタイプのシステムで
利用するには、性能的なリスクの大きなインデックス。


ハッシュインデックス
ハッシュインデックスは、ハッシュ関数という関数を使ってデータの値をハッシュ値に変換してインデックスを保持する。
ハッシュ関数とは、入力値が異なれば出力値も異なるような関数のことで、データの分散に利用する。
ハッシュインデックスは、等値検索、つまり「=」を使った検索条件においては非常に高速な検索を実現する。
B-treeインデックスでは、目的のリーフを見つけるまでに数回の読み込みが必要なのに対して、ハッシュインデックスは
いきなり1回の読み込みで目的地にたどりつける。

ハッシュインデックスの欠点は、利点の裏返し。それは等値検索以外ではこのインデックスが利用できないこと。
範囲検索には、ハッシュインデックスは使えない。その理由は、ハッシュ関数で変換されたハッシュ値は、
元の値の順序関係を維持していないから。このため、ハッシュ値を使って範囲検索というのは不可能。

ビットマップインデックスやハッシュインデックスは、使う条件によってはB-treeインデックスを凌駕する性能を
見せるのだが、いかんせんその条件が狭すぎて、使いどころが難しい。


演習6-2 インデックスの再編成
まず、どのDBMSでも共通の最も簡単な方法は、一度インデックスを削除して、もう一度作成すること。
この方法は非常に明快だが、リスクもある。それは、インデックスを削除した後、作成するコマンドが
何らかの理由でエラーになって失敗してしまうと、問題が解消されるまでそのデータベースは
「インデックスがない」状態が続いてしまうこと。
この間に実行されるSQL文は、もちろんインデックスを利用できず、性能問題を引き起こす。
この欠点を補うために、DBMSはインデックスを削除しなくても再編成できるための手段を提供している。

Oracle
ALTER INDEX インデックス名 COALESCE;

ALTER INDEX インデックス名 REBUILD;

上記の二つのコマンドによって、すでに存在するインデックスに対して実行することで、
インデックスを削除することなく再編成できる。
両者の違いは、「COALESCE」がリーフブロックの結合だけを実行するため高速だが、簡易な再編しか行わないのに対し
「REBUILD」は本格的な再編を行うため時間がかかる。

SQL Server
ALTER INDEX インデックス名 REORGANIZE;

ALTER INDEX インデックス名 REBUILD;

SQL Serverにも、Oracleと同様、二つのレベルで再編成コマンドを用意している。
「REORGANIZE」が簡略版、「REBUILD」が本格的なもの。



DB2
REORG INDEX インデックス名;

DB2では「REORG」というコマンドを用いる。コマンドとしては一つだが、
オプションが非常に豊富で、細かい指定を行うことができる。


PostgreSQL
REINDEX インデックス名;

PostgreSQLでは「REINDEX」というコマンドを用いる。オプションで細かい制御ができるので、
詳細はマニュアルを参照する。


MySQL
OPTIMIZE TABLE テーブル名;

MySQLでは、不思議なことにインデックスの再編成を行うためにテーブルの再編成を行う。
この「OPTIMIZE」コマンドは、もちろん第一義的にはテーブルの再編成（デフラグ）を行うための
コマンドなのだが、実行すると、あわせて該当テーブルに作られているインデックスの再編成も行われる。



第7章
論理設計のバッドノウハウ

この世界は、バッドノウハウ（アンチパターン）と呼ばれる、ろくでもない設計であふれている。
システムの心臓であるデータベースの設計におけるバッドノウハウは、システム全体としての品質を
致命的なレベルで損なってしまう。
そのような罪深いバッドノウハウの具体的な症例を検討し、なぜバッドノウハウは生まれるのか、
そのどこが「悪」であるのかを明らかにする。


学習のポイント
・リレーショナルデータベースにおける論理設計の基本は、正規化。
しかし、世の中には、この原則に反した設計がおく存在する。
これをバッドノウハウ、またはアンチパターンと呼ぶ。

・バッドノウハウは、正規化からは導かれない。また、非正規化によって生まれるわけでもない。
（非正規化はトレードオフを理解している限りバッドノウハウではない）。

・バッドノウハウがダメなのは、これがシステムの品質を左右するうえに、
後から変更することが容易でないから。

・論理設計の代表的なバッドノウハウには、非スカラ値、ダブルミーニング、単一参照テーブル、
テーブル分割、不適切なキー、ダブルマスタがある。


7-1
論理設計の「やってはいけない」
真似してはいけない設計のパターンをIT業界では「アンチパータン」や「バッドノウハウ」。
わざわざこのようなパターンに注目するのは、それだけ世の中にそいういう設計が多く存在しているということ。
システムの品質を決めるのは、設計。プログラミングというのは、設計をプログラミング言語に翻訳する作業であって、
プログラミング自身がシステムの品質を左右することは、相対的にはまれ。
「戦略の失敗を戦術で取り返すことはできない」という有名な言葉があるが、システム開発においては、
設計が戦略、プログラミングが戦術に相当する。


7-2
非スカラ値（第1正規形未満）

配列型による非スカラ値
1999年の改訂で標準に盛り込まれた機能「配列型」というものがある。
ここでの「配列」はJavaやC言語など通常のプログラミング言語における配列と同じ意味。
これはテーブルの一つの列を配列として扱うことができる機能。
非スカラ値を含むテーブルを作ることができる、と言うことなので、
リレーショナルデータベースの掟破りとも言うべき機能。

結局のところ、この配列型は、機能としてはサポートされたものの、それほど一般的に普及するには至らなかった、
というのがここ10年間の結果。データベース側だけが配列型に対応したとしても、データベースと接続する
アプリケーションやミドルウェアも対応しなければ意味がないため、まだ実用化へのハードルが高い。
現状としては、容易に配列型を使用するのではなく、第1正規形を確保することを優先するべき。


勘どころ48
配列型は利用しない。第1正規形を守る。

リレーショナルデータベースのテーブルはかなり固定的な性格を持っていて、後になってから列を
増減させるようなテーブル構成の変更コストが高くつく。
配列型のような、よく言えば「柔軟」なデータ型が欲しい、という気持ちもわかる。


スカラ値の基準は何か？
この問いには、一定の答えはない。
どのような単位でテーブルの列を作るか、という決定は、システムの要件次第。
一般論としては意味的に分割できる限り、なるべく分割して保持する、ちう基本方針が良い。
その理由は、分割したものを後で結合することは簡単にできるのに対し、
結合された状態のものを後から分割するのは比較的難しいから。
情報は可能な限り分解し、原始的な形でデータを保持することが望ましい。


勘どころ49
情報は可能な限り分解して保存するのが良い。ただし意味を壊してはいけない。


7-3
ダブルミーニング

この列の意味はなんでしょう？
同一の列が二つの意味を持つ「ダブルミーニング」の状態になっている。
テーブルを作成した人が「2002年は体重はもう必要なくて、代わりに年齢だけわかればいい」と
判断した結果、このような奇妙なテーブルが誕生した。

このテーブルを見た瞬間、「これは反則だろう」と思った方もいると思う。
反則なのですが、やろうと思えばこのようなテーブルを作ることは可能。
こうしたダブルミーニングの列が許されない理由は、列の意味が不明確になることで、
システムのバグを生み出す原因にもなるから。
実際に、このようなテーブル設計を行うと、列名を見てもこの列が何のデータを
格納しているのか、判別できない。ダブルミーニングの列は、運用途中で意味が変わってしまうため、
「体重」とか「年齢」といった固定的な列名を付けることができないから。


テーブルの列は「変数」ではない
このようなダブルミーニングの列が作られる背景として考えらるのが、
プログラミング言語における「変数」の存在。プログラミングを行う際には、
雑多な値を格納するための一時変数がよく使われる。
そうした変数の名前も、やはり特定の意味を持たないため「tmp」や「var」という名前が付く。
こうしたプログラミングの習慣に慣れたエンジニアがリレーショナルデータベースの
テーブルを見ると、「値を格納するわけだから、これも一つの変数なんだな」
と考えるのはある意味自然なこと。
リレーショナルデータベースにおけるテーブルは、意味的には現実の世界にある
いろいろな実体（エンティティ）の「写像」、つまり物を写しとったものであるため、
変数よりもずっと静的で固定的な存在。
テーブルや列の意味は、一度決めたら容易に変更してはならないものである、
というのがリレーショナルデータベースの世界における取り決め。


勘どころ50
列は変数ではない。一度意味を決めたら変更不可。


7-4
単一参照テーブル

多すぎるテーブルをまとめたい？
「都道府県」や「性別」といったマスタ類のエンティティは、同様のテーブル構造を
持つわけだから、こうしたマスタ群を一つにまとめてしまいたいという考えは、
それほど不自然なものではない。
こうした発想で作られたテーブルが、単一参照テーブル。
あらゆるタイプのマスタテーブルを、一つのテーブルに放り込んでごった煮したもの。


単一参照テーブルの功罪
テーブル全体が、あるときは「会社」、あるときは「性別」へと七変化する。
この考え方を、オブジェクト指向言語における「ポリモルフィズム」の機能に
似ている、と指摘するエンジニアもいる。
ポリモルフィズムは、多能性や多様性とも呼ばれ、
オブジェクトや関数が複数の型に属することを意味する概念。
この単一参照テーブルの利点と欠点をまとめると、以下のようになる。

利点
・マスタテーブルの数が減るため、ER図やスキーマがシンプルになる。
・コード検索のSQLを共通化できる。

欠点
・「コードタイプ」「コード値」「コード内容」の各列とも、必要とされる列長は
コード体系によって異なるため、余裕を見てかなり大きめの可変長文字列型で宣言する必要がある。

・一つのテーブルにレコードを集約するため、コード体系の種類と数の多さによっては、
レコード数が多くなり、検索のパフォーマンスが悪化する。

・コード検索のSQL内でコードタイプやコード値を間違えて指定しても
エラーになることがないため、バグに気付きにくい。

・ER図がすっきりするとは言っても、ERモデルとしては正確さを書いていて、
かえってER図の可動性を下げることになる。


勘どころ51 
テーブルにポリモルフィズムはいらない。


7-5
テーブル分割

テーブル分割は一般的にパフォーマンス向上を目的として実施されることが多く、
目的がはっきりしていることもあって、他に比べるとそれほど
バッドノウハウとは認識されていない。
テーブルの分割の方法には何種類かあり、ものによっては現実的な解であることもある。
しかし、中には絶対に許されないタイプの方法もあるため、注意が必要。


テーブル分割の種類
テーブル分割を分類すると、大きく二つに分かれる。
①水平分割
②垂直分割

「水平分割」とは、レコード単位にテーブルを分割すること。
テーブルを水平にカットするのでこう呼ぶ。

「垂直分割」は、列単位にテーブルを分割する。

厳密には分解ではないが、「集約」というものも存在する。
これは、元のテーブルのデータの一部をサマリ（集計）した結果を、
新たなテーブルとして保持するパターン。
テーブルは追加されるだけで元のテーブルの構成が変更されるわけではない。
開発時にはパフォーマンス向上のための手段として、テーブル分割と一緒に考えられている。


水平分割
水平分割とは、レコード単位でテーブルを分割する手段。
実際の業務システムではテーブルに何百万〜何十億という数のレコードが含まれる。
その結果、テーブルにアクセスするSQL文のパフォーマンスが悪化することが起きる。
SQL文のパフォーマンス悪化が起きる最大の原因（ボルトネック）は、
ストレージ（多くの場合はディスク）に対するI/Oコストの増大だった。
その場合、アクセスするデータ量を減らすことが、パフォーマンス改善の手段になる。

SQL文がアクセスするテーブルのサイズを極力小さくするということ。
たとえば、SQLが常に1年ごとにしか「売上げ」テーブルにアクセスしないのであれば、
次のように年度ごとにテーブルを分割することでパフォーマンスを改善できる。

次のような重大な欠点もあるため、リレーショナルデータベースでは原則禁止とされる。

欠点1 分割する意味的な理由がない
     これはすべてのパターンのテーブル分割に該当するが、このようにテーブル分割をする理由は、
     正規化の理論からは出てこない。純粋にパフォーマンスという物理レベルの要請によるものなので、
     逆に言うとその要請がなければ実施する必要のないもの。

欠点2 拡張性に乏しい
     この分割がパフォーマンス改善に効果を発揮するのは、全年度のデータを総なめで検索することはない、
     という前提が成立する場合だけ。そして、その前提が常に成立するかどうかは保証の限りではない。
     経年変化を分析したい、といった場合にはこの分割方法では意味がない。
     年を重ねるごとにテーブルも増えていくのでその度にアプリケーションの改修が必要となり、
     拡張性に欠ける。

欠点3 他の代替手段がある
     こうした水平分割の手段として、多くのDBMSが「パーティション」という機能をもっている。
     パーティション機能を用いることで、テーブルを分割することなく、パーティションキーを軸として
     物理的に格納領域を分離することが可能になる。
     これによって、SQLがアクセスするデータ量を1/nに減らすことができる。
     一般的にはパーディションはインデックスよりもカーディナリティが小さく、かつ値の変化があまり
     起きない列をキーにして利用する。


垂直分割
水平分割がレコードを軸にした分割だったのに対して、垂直分割は列を軸に分割する。
この垂直分割も分割することが論理的な意味を持たないという水平分割と同様の欠点があるため、
原則利用するべきではない。垂直分割の場合は、「集約」で代替が可能。


集約
集約は、テーブル分割ではなく、テーブル分割の代替案に位置づけられる方法。
その種類は細かく2つに分かれる。
①列の絞り込み
②サマリテーブル

①列の絞り込み
一つ目が、単純に保持する列を絞ったテーブルを作成するタイプ。
これは、垂直分割に対する代替案に相当する。
頻繁に参照される列だけを持った新しいテーブルを追加作成する。
オリジナルのテーブルは残すため、分割ではない。
このようにして作られる（オリジナルのテーブルと比較すれば）小規模なテーブルをデータマート、
あるいは省略して単にマートと呼ぶ。
マートは、非常に便利で、オリジナルのテーブルを意味的に破壊することなくパフォーマンスも向上させられるため、
実際の開発においてもよく利用されている。
便利でマートばかりたくさん作られてしまい、ストレージの容量を圧迫するという本末転倒なケースも時折見る。

マートを利用する際に注意すべき点がデータの同期の問題。
問題となるのは、マートの更新タイミング。タイミングが短いほど、オリジナルのテーブルと齟齬がある期間も
短くなるので、データ精度が高く機能的にも好ましいが、更新タイミングが短いほど処理の負荷が上がり
性能問題を悪化させてしまう場合もある。


サマリテーブル
サマリテーブルも集約の一手段。
列の絞り込みと違うのは、サマリテーブルは集約関数によってレコードを集約した状態で保持すること。






7-6
不適切なキー
データベースでテーブルを作る際に考える要素の一つとして、どの列にどのようなデータ型を採用するか、
という問題がある。
代表的なデータ型には、次のようなものがある。

・文字列（CHAR,VARCHAR）
・数値（INTEGER,LONG,REAL）
・日時（DATE,TIMESTAMP）


問題となるのは、キーに使用される列に対するデータ型。ここで言う「キー」とは、次の二つを指す。
・主キー、外部キーなどデータベースの機能で設定されるもの
・テーブルの結合条件で使用される列（結合キー）

この2種類のグループは、互いに重なり合っていることがほとんど。
結合で使われるキーというのは、該当テーブルの主キーや外部キーであるのが普通。
この二つの用途で使われる列には、明らかに使ってはいけないデータ型がある。
それが、可変長文字列（VARCHAR）。理由は二つ。
一つは、可変町文字列の列は、キーが満たすべき条件である不変性（Stability）を備えていないこと。
もう一つが、固定長文字列（CHAR）との混同。


キーは永遠に不変です！
可変長文字列が使用されるのは、具体的にどのような種類のデータか？
何かの「名前」に使われることが多いということ。名前は文字数が固定ではないから、
名前の列に可変長文字列が採用されるのは自然。
しかし、「名前」をキーに使うことは非常に危険。
名前は長期的なスパンで考えれば、変動する可能性が高い。
コロコロ値が変わる列をキーにすると、データの更新処理が多く発生することになるため、
システムの安定的な運用とパフォーマンスの両面でマイナス。


勘どころ52
可変長文字列は不変性がないためキーには不向き。


同じデータを意味するキーは同じデータ型にすべし
固定長文字列と可変長文字列は、同じ文字列を保持しようとしても、
物理的には同じ「値」にならないことがほとんど。
それは、固定長文字列が空白による穴埋め（パディング）をするから。

ある結合キーについて、一方のテーブルが固定長文字列で宣言されていて、他方のテーブルでは
可変長文字列で宣言されてると、単純に列同士を比較するとアンマッチになってしまう。
この問題は、文字列型と数値型など異種のデータ型の間でも起きる。
DBMSによっては暗黙のデータ変換を行なってくれることもあるが、それでも、
固定長文字列の「001」と数値型の「1」は、型変換だけでは不十分で、数値型のほうを
「0埋め」しなければマッチしない。こうした厄介な問題にSQLコーディングの時点で
頭を悩ませるぐらいなら、最初からデータ型を固定長文字列型に揃えておくべき。


勘どころ53
キーには固定長文字列の「コード」列が望ましい。


7-7
ダブルマスタ
ダブルマスタとは、同じ役割を果たすはずのマスタテーブルが二つ存在するようなケース。


ダブルマスタはSQLを複雑にし、パフォーマンスを悪化させる。

ダブルマスタはなぜ生じるのか
ダブルマスタが生じる直接的な理由は一つで、それは、もともと別のシステムで利用されていた
マスタ同士が、システム統合によって同じドメインに存在するようになった場合。


勘どころ54
ダブルマスタはシステム統廃合で起きることが多い。



演習問題
演習7-1 パーティションの特徴
どのような利点と欠点を持っているかを整理する

・レンジパーティション
レンジパーティションは、パーティション機能の中で最も基本的なもので、頻繁に利用する。
インデックスで言えばB-treeに相当する。
レンジパーティションは「レンジ（範囲）」という名称のとおり、ある列をキーにして、
その値の範囲によってパーティションを分割する。
必然的に、順序を持ったデータにしか適用できない。一般的には、年月や時間といった
時系列をキーにすることが多い。


・リストパーティション
リストパーティションは、原理的にはレンジパーティションと同じ。
特定のキーの値を使ってレコードをパーティションごとに振り分ける。
違うのは、リストパーティションが連続的なキーではなく、離散的なキーに利用されること。

レンジパーティションとリストパーティションを利用するときの基本方針
方針1 なるべく各パーティションに含まれるレコード数が同じくらいになるキーを選ぶこと。
     そうでないと、キーによってI/O量が大きく変わってしまい、性能が安定しない。

方針2 SQL文で選択条件/結合条件に利用されるキーを選ぶこと。
     せっかくパーティションでデータを区切っても、SQL文で利用されなければ意味がない。

方針3 値があまり変更されないキーを使うこと。パーティションにレコードが格納された後に、キー値が
     変更されると、パーティション間のレコード移動が発生する。それ自身も性能問題を起こすが、
     パーティション間のレコード件数の分布（ヒストグラム）も崩れてしまうため、
     あまり変動要素の大きいキーを使うことは推奨できない。


・ハッシュパーティション
ハッシュパーティションは、前二者のパーティションとは毛色が違う。
これは名前のとおり、ハッシュ関数でパーティションキーの値を分散させる。
一般的にはパーティションの数がいくつになるかを事前にユーザー側が指定しない使い方をする。
原理的にはハッシュインデックスと同じと考えても良い。
ハッシュ関数を使っているという特性上、ハッシュパーティションは、パーティションキーを使った範囲検索では
意味を持たない。あくまで一意検索でしか効力を発揮しないのがハッシュパーティションの弱み。

7-2 マテリアライズドビューの機能
マテリアライズドビュー（Materialized View）は、日本語に訳すと「実体化されたビュー」で、
文字通り、実データ（レコード）を保持するビューのこと。
これは、ビューというよりほとんどテーブルに近い存在。

マテリアライズドビューがパフォーマンス面で有利な理由
利点1 実データを保持するので、通常のビューと異なり、アクセス時にビュー定義のSELECT文が実行されない。

利点2 主キーをはじめとしてインデックスを作成することができる。

普通のテーブルと同じ扱いができる、というのが大きな利点。

一方の欠点は、
欠点1 リフレッシュの管理が必要。

欠点2 普通のテーブルと同様にストレージを消費する。

どちらも、普通のビューを使っている時には怒らない問題。リフレッシュを怠れば、元のテーブルとデータが
食い違ってしまう。そのため、定期的にリフレッシュを行なって元のテーブルとデータの同期をとる必要がある。
これは、通常のテーブルでデータマートを作る場合と同じ。実データを保持するため、ストレージの容量も消費する。



第8章
論理設計のグレーノウハウ

データベースの論理設計には、明確にバッドノウハウとまでは言えないものの、
きわどいライン上に位置するグレーゾーンが存在する。
グレーゾーンは、利点と欠点のバランスが拮抗していて、使用の際は慎重な判断が求められる。

・バッドノウハウ以外にも、違法スレスレの「グレーゾーン」の設計、グレーノウハウがある。

・グレーノウハウは、節度ある利用にとどめる限り、有効に作用する「良薬」になりえるが、
利点と欠点のバランスを慎重に考える必要がある。

・グレーノウハウには、代理キー、列持ちテーブル、アドホックな集計キー、多段ビューがある。

8-1
違法すれすれの「ライン上」に位置する設計

システムの世界にも、グレーゾーンが存在する。バッドノウハウとはっきり断定することこそできないものの、
無神経に使うと開発や運用に支障をきたすような、そんな毒を含んだ設計のこと。
これをグレーノウハウと呼ぶ。
グレーノウハウは用法容量を守れば役に立つけど、間違った使い方をすると副作用の強い薬のようなもの。


8-2
代理キー 〜主キーが役に立たないとき〜
リレーショナルデータベースのテーブルにおいて、原則主キーが必ず必要である。
しかし、その主キーを決めるのが容易でないケースがある。


主キーが決められない、または主キーとして不十分なケース
パターン1 そもそも入力データに主キーにできるような一意キーが存在しない。
パターン2 一意キーはあるが、サイクリックに使いまわされる。
パターン3 一意キーはあるが、途中で指す対象が変化する。


パターン1 そもそも入力データに主キーにできるような一意キーが存在しない。
最も単純だが、同時に言語道断なケース。テーブルを作ろうにも、一意キーが存在しないのでは主キーが決められない。


パターン2 一意キーはあるが、サイクリックに使いまわされる。
主キーの値がすべて使われてしまった場合に、既存の値が使われるケースで起こる。


パターン3 一意キーはあるが、途中で指す対象が変化する。
主キーの指す対象が途中で変わってしまうと言う点で、パターン2と似ている。
その理由が値の枯渇ではないだけ。


代理キーによる解決
問題を解決する手段として利用されるのが、代理キー（surrogate key）「サロゲートキー」とも呼ぶ。
名前の通り、入力データに最初から存在しているキーの「代理」として新たに追加するキー。
一般的な原則として、極力代理キーの使用は避けて、自然キーによる解決を図る。
代理キーがそもそも理論的には不要なキーであるため、代理キーが何の役割を果たしているのかは、
ER図を一読してもわからない。代理キーは本来「使わなくても何とかなる」道具。


自然キーによる解決
自然キーを主キーとする場合に問題が発生する三つのパターンを再度取り上げる。
パターン1については、自然キーに主キーが存在しないケースなので、データベース側で打つ手はない。
業務仕様を調整するか、データベースに投入される前のアプリケーションでデータが一意になるよう整形する
対策を行う。

パターン2とパターン3のケースについては、基本的に自然キーによる解決が可能。
その方法は、履歴管理のための時間を表す列を追加する方法。
この時間を示す列には、タイムスタンプとインターバルの2種類がある。


タイムスタンプ
データのスナップショット（断面）を必要な数だけ用意する方法。
それぞれの断面が履歴の役割を果たす。
変更数が多いデータの場合は、レコードが膨大になってしまう。


インターバル
タイムスタンプがある「時点」を意味したのにたいし、データの有効な「期間」を表す方法。



オートナンバリングの是非
代理キーと自然キーに関する議論の結論としては、前節までで見たように、
「可能な限り自然キーを使う」という一点に尽きる。
実際の現場の開発においてはやむおえず代理キーを使わざるを得ない場合もある。
代理キーを実装する際、しばしば利用される方法が「オートナンバリング」。
これは、1レコードに一意な（通常は整数型の）数値を自動的に割り振る方法。

主キーとして使うことから次の二つの要件が守られないといけない。
要件1 重複値が生じないこと（一意性の保証）
要件2 歯抜けが生じないこと（連続性の保証）

二つの要件のうち、一意生が保証されなければならないのは、当然。
二つの要件をクリアするには、二つの方法が考えられる。
それが、データベースの機能を利用する方法と、アプリケーションを利用する方法。

オートナンバリングの実現方法①〜データベース機能
データベースの機能を利用する方法から説明すると、標準SQLには、
オートナンバリングを実現するために、次の機能が定義されている。
・シーケンスオブジェクト
・ID列


シーケンスオブジェクト
「順序」という名前の意味するとおり、これにアクセスすることで一意な連番を払い出すオブジェクト。
SELECT文でアクセスすることによって重複のない連番を取得することが可能。
開始値、最大値、カウントアップの増分（一つずつ増えるか、飛び石で増やすか）最大値まで達した
ときんサイクリックに開始値から再び採番するか、といった様々な条件をオプションで指定できるので、
柔軟性に富む。

比較的新しい機能であることから、まだすべてのDBMSがサポートしているわけではない。



ID列
データベースの機能でオートナンバリングを実現するもう一つの方法は、ID列。
一意な連番を払い出すデータ型。テーブルで使用する主キーとして、このデータ型を採用する。
（別にID列そのものは、主キー以外の列として使うこともできる。）
シーケンスオブジェクトに比べると指定できるオプションが少なく、開始値と増分くらい。

ID列にはもう一つ難点がある。DBMSごとに実装が統一されていないため、移植性が低い。
名前もバラバラで機能も微妙に異なる。

勘どころ55
シーケンスとID列では、シーケンスのほうがより柔軟で拡張性に富む。


オートナンバリングの実現方法②〜アプリケーション側で実装
オートナンバリングの実現をするもう一つの方法は、データベースの機能に頼らず
アプリケーション側で実装する方法。
最もポピュラーな方法は、「採番テーブル」を利用するもの。
1行1列の整数型のデータを持つ採番テーブルを用意し、他のテーブルにデータを登録するたびに
インクリメントしていくという方法。


勘どころ56
オートナンバリングをアプリケーションで実装するのは「車輪の再発明」。


シーケンスオブジェクトと採番テーブルの共通の、そして巨大な欠点は、
ロックが起きることで、同時アクセスが多数集中したときに、この連番の払いだし処理が
ボルトネックとなり、性能遅延が発生する可能性があること。
ロックは連番の一意生を保証するために必要なロジックなので、原理的にこの現象を防ぐことはできない。


8-3
列持ちテーブル
配列型は使えない、でも配列を表現したい
配列型を使わずに配列を模倣する論理設計がある。それが「列持ちテーブル」。
別名「繰り返し項目テーブル」とも呼ばれる。


列持ちテーブルの利点と欠点
利点1 シンプルな設計
      列持ちテーブルの利点は、そのシンプルさにある。正規化とかスカラ値とか、
      小難しいことを知らない人でも、このテーブルを見れば一目で、子1、子2、子3の各列が
      配列を表現しているのだということがわかる。

利点2 入出力のフォーマットと合わせやすい
      このテーブルは、アプリケーションサイドとのインタフェース設計も非常に簡単になる。
      

欠点1 列の増減が難しい
     リレーショナルデータベースのテーブルは、一度作ると、後になってから構成を変更することが
     難しいという特徴がある。つまり拡張性に乏しい。
     技術的にはできるが、アプリケーション側もあわせて変更する必要が出るなど、変更コストが高くなる。
     テーブルの列も同じで、配列ほど柔軟に要素数を変化させることができない。

欠点2 無用のNULLを使わなくてはならない
     列持ちテーブルのもう一つの欠点は、子がいない、または子の少ない社員について、
     子の列にNULLを使わなくてはならないこと。
     NULLというのはリレーショナルデータベースにおいて非常に厄介な性質をもっていて、
     NULLが演算に含まれているとSQL文の結果を混乱させる原因になる。


行持ちテーブル
列持ちテーブルは、利点と欠点のバランスが拮抗しているため、使いどころによっては有用。
特殊な状況でない限り、原則として列持ちテーブルは使うべきではない。
基本的には「行持ち」のテーブル構成を採用するべき。
行持ちテーブルは、列持ちテーブルに比べて、欠点の少ない定石。


行持ちテーブル
行持ちテーブルと列持ちテーブルの変換は保証されているうえにSQL一発で可能なので、
最初は拡張性の高い行持ちテーブルでデータを保持しておき、パフォーマンス上の問題で
どうしても列持ちテーブルが必要になった場合に、列持ちテーブルを作るという方針が良い。


8-4
アドホックな集計キー
これは、DWH/BI分野の論理設計を行う際によく問題になる。

アドホックな（場当たり的な）キーは、名前のとおり、コード体系が短いスパンで変わったり、
別のコード体系が必要になったりする。そのたびに、サイズの大きいテーブルにアドホックキーを
次から次へと追加すると、ただでさえ規模の大きなテーブルがますます巨大になって、
パフォーマンスを劣化させる。
この問題を解決する手段は三つある。


解決策1 
一つ目の解決策は、キーを別テーブルに分離すること。
この場合であれば、都道府県と地方の変換テーブルを作ることになる。
この変換テーブルのレコード数はトランザクションテーブルに比べてかなり小さくなることが期待でき、
メンテナンスも容易。SQLでは結合処理が必要になるため、パフォーマンス問題の解決にあまり寄与しない。

解決策2
二つ目の解決策は、ビューを使うこと。オリジナルのテーブルには手を加えずに、地方コードを追加したビューを
用意すれば、そのビューへのアクセスによって簡単に地方単位の集計を行うSQLが記述できる。
実質的にオリジナルのテーブルへアクセスしているのとコストは変わらないため、必要なコードの数だけ
ビューを作っても、パフォーマンスを劣化させることがない。

解決策3
最後の選択肢はGROUP BY句の中でアドホックキーを、「アドホック」に作る方法。
具体的にはCASE式で次のようにコードの読み替えを行う。
CASE式は式の仲間なので、式が書ける場所にはどこでも書ける。
具体的にいえば、SELECT句だけでなく、WHERE句、GROUP BY句、HAVING句、ORDER BY句に書くことが可能。
この万能ぶりから、数あるSQLの機能の中でも重宝する。


8-5
多段ビュー
ビューは、リレーショナルデータベースを用いた開発においては非常に有用な道具。
SELCT文を保存して、一種のテーブルとして扱うことができるため、正規化されたテーブルの結合など、
複雑な操作を要するSELCT文をビュー化しておくことで、上位レイヤーのアプリケーションの
プログラミングを簡潔に行えると言う利点がある。
テーブルを隠蔽してユーザーに必要なデータだけを必要な形で見せられることから、外部スキーマに属する。
ビューを「クエリの缶詰」と表現する。保存がきくうえに、開けば常に新鮮なデータを取り出せる
というわけで、なかなか巧みな比喩。
何事につけて「いいとこどりは存在しない」というのがシステム開発における第一原則。
ビューも長所ばかりではない。ビューの短所は、パフォーマンスへ悪影響を与えることと、
濫用すると帰って設計と実装を複雑なものにしてしまう。


ビューへのアクセスは「２段階」で行われる
ビューというのはテーブルと違って、データを保持しない。
ビューは利用者からの見た目上、テーブルと同じように扱うことができる。
SQL文の構文上でも、テーブルとまったく同じ構文で扱う。
初級者はビューとテーブルの違いに無頓着になりがちだが、物理的なレベルで見れば、
ビューとテーブルは「月とすっぽん」というやつ。
ビューは実はデータを保持しないという点で、物理的にはSELECT文が書かれたファイルにすぎない。
ビューに対してSQL文によってアクセスが行われたとき、
ビューはどうやってデータを取り出しているのかといえば、結局のところ、ビュー定義の
SELECT文を実行して、オリジナルのテーブルにアクセスしている。
ビューへアクセスするときは、2段階のSQLが発行されているようなイメージを持つ。


多段ビューの危険性
ビューへのSQL文によるアクセスにおいては、常に背後に存在する
基底テーブルの存在を意識しておく必要がある。
元々ビューは基底テーブルを隠蔽する技術でもあるのだが、本当に基底テーブルを意識しなくても
いいのはエンドユーザーだけであって、エンジニアは常に意識しなければならない。
エンジニアは、決して物理層から自由になれない。

勘どころ57
ビューの背後にあるテーブルの存在を、常に意識せよ。

ビューの使用は、原則として1段にとどめておくようにする。
システムの世界には、「過度に複雑な作りはシステムをだめにする」という思想がある。
この思想を表現するスローガンを「KISSの原則」と言う。


勘どころ58
Keep It Simple,Stupid （単純にしておけ、このバカ）





8-6
データクレンジングの重要性

リレーショナルデータベースを利用する/しないにかかわらず、システムで扱うデータを
データベースによって一元管理することは、システム化による業務効率化の第一歩。
データベースを構築するに当たっては、それまでの業務で利用されていたデータを
データべースに登録できる状態にすることが必要になる。
この作業をデータクレンジングと呼ぶ。
データクレンジングが終了しないと、正規化のような方法論も利用することができないし、
バッドノウハウやグレーノウハウが発生する理由の一つも、データクレンジングをおろそかにすることにある。


データクレンジングは設計に先立って行う
「効率的なシステムにはデータクレンジングが必要」ということを逆からとらえると、
通常業務データは、掃除が必要な「汚れている」状態ということ。
これは、そのデータがあらゆる意味で「使えない」ということではない。
それまでも既存のデータを利用して業務が行われてきた以上、
既存業務の目的には合致したフォーマットではあった。
ただ、新たに構築されるシステムにとっては、使えなかったり非効率的なフォーマットで
あったりすることを「汚い」と表現している。
データベースの論理設計にとりかかる前に、入力データのフォーマットが適切なものか調査し、
必要であればデータそのものの変更やフォーマット変換が必要になる。
つまり、データクレンジングはデータベース設計に先立って行う必要がある。
特に厄介なのが、もともとシステム化されていなかった業務を初めてシステム化する場合、
システムは利用されていても、リレーショナルデータベース以外のフォーマットのデータベースが
利用されていた業務をリレーショナルデータベースに差し替えるような場合。


代表的なデータクレンジングの内容
一意キーの特定
リレーショナルデータベースの考え方に慣れてくればくるほど、レコードを一意に
特定することのできる一意キー（ユニークキー）の存在は、当たり前のように思える。
しかし、意外に世の中で行われている多くの業務では、データの一意性については注意が
払われていないことも多くある。

勘どころ59
一意キーの存在しないデータは、バッドノウハウ「不適切なキー」をも生み出す。


名寄せ
名寄せとは、「似通った名前を寄せ集めて統合する」と言う意味。
人命や企業名の表記揺れを解消して名称を統一する。その意味で、標準化の一種に数えられる作業。

名寄せが発生する根本的な原因は、情報を記録する際に標準的なフォーマットを決めず
「フリーハンド」の入力を許していることにある。
フリーハンドは、複数のフォーマットが混在すると言う問題はもちろん、
単純な誤記を許してしまうという欠点も持っている。
最近では、名寄せにかかるコストを抑えるため、事前に統一された入力フォーマットを用意して、
最初から名寄せが発生しないデータを作ることも意識されている。

名寄せをサボって複数のマスタテーブルを統合しないまま残すと、バッドノウハウ
「ダブルマスタ」を生み出すことになる。


勘どころ60
名寄せをサボると、バッドノウハウ「ダブルマスタ」を生み出す。


演習問題
演習8-1
ビジネスロジックの実装方法の検討
問い1 ビジネスロジックをアプリケーションコードで実装することの是非
ビジネスロジックをアプリケーションコードで実装すること自体は、認められるべき。
リレーショナル原理主義的な人の間では「ビジネスロジックはテーブルの制約として実装するべきであって、
アプリケーションで実装するのは邪道である」と言う主張もある。
例えばテーブルの列のデータが「100以下の数値である」という条件を満たさなければならない、
というビジネスロジックがあった場合、データの入力時にアプリケーションでチェックするのではなく、
テーブルにCHECK制約を付与することで実現するべきだ、という立場。
手続き（コード）を宣言（定義）で置き換えていうというリレーショナルデータベースの
基本思想に合致する、合理的な主張。
実際問題として、テーブルの制約だけでビジネスロジックを実現するのは、現状いろいろと困難がつきまとう。


困難1 複雑なビジネスロジックを実装できない
CHECK制約は複数のテーブル間の関係を記述することはできない。CHECK制約はまた、同一テーブル内であっても、
レコードをまたいだ条件を記述することもできない。
ビジネスロジックを実装しようにも、現在のDBMSの機能では不足している。
複雑なビジネスロジックをデータベース側で実装するための機能を「表明（Assertion）」といって、
標準SQLにも含まれているが、まだまだDBMS側のサポートは遅れている。
「ビジネスロジックのうち、データベース側で実装できるものは
データベース側で、できないものはアプリケーション側で」という折衷案を採用する
システムも見かけるが、これをやると結局、ビジネスロジックの実装箇所が分散されて、
どのビジネスロジックがどこで実装されているかわかrなくなり、管理が面倒。


困難2
エラーハンドリングが難しい
ビジネスロジックをデータベース側に実装することのもう一つの困難は、エラー時に発生する。

結論
主キー、参照整合制約、NOT NULL制約というリレーショナルデータベースにとって
基本的なルールはデータベース側で実装する。
それ以外のビジネスロジックはアプリケーション側で実装する。



問い2 ビズネスロジックをデータベースの「トリガー」で実装することの是非
ビジネスロジックの多くはアプリケーションコードで実装する、という結論に達した。
リレーショナルデータベースも、それを実装するための手段を二つ持っている。
一つが「ストアドプロシージャ」、そしてもう一つが、この問題の主題である「トリガー」。
「ストアドプロシージャ」は、「保存されたプロシージャ」という名前のとおり、
アプリケーションではなく、DBMS内にコードを保存する手続き型言語。
略して「プロシージャ」とも呼ぶ。

一方の「トリガー」は、手続き型であるとか、DBMS内にコードが保存される、
という点ではストアドプロシージャが、ユーザーが（SQLのように）明示的に実行しないと
実行されないのに対して、トリガーは、テーブルへの更新（INSERT,UPDATE,DELETE）を
契機として自動的に実行（発射）されること。
トリガーとは「引き金」と言う意味だが、テーブルの銃の「引き金」を引っ張っておいて、
更新されたら自動的に銃が発射されるイメージ。
いろいろな処理で同じようなデータベースの更新を行わなければならない場合、
処理を一箇所にまとめる「モジュール化」と同じ効果を期待できる。
トリガーは非常に危険なので、使うべきではない。代わりにストアドプロシージャを使う。
その理由は、
理由1 実装ごとに文法がバラバラで統一性がない。
理由2 オプティマイザによる最適化を受けられない。
理由3 エラーハンドリングが難しい。
理由4 アプリケーション以外の更新でも発射されるため、開発が難しくなる。


勘どころ61
銃規制で安全な開発を実現する。


演習8-2
一時テーブル
アドホックなデータ、つまり一時的にしか使わず、処理が終わればなくなってかまわないような
データを用意する手段として、DBMSは「一時テーブル」という機能を用意している。
この機能についての使うことの是非を考える。

一時テーブルとは、「一時的なデータ」を保持するためのテーブル。
「テンポラリテーブル」や「一時表」とも呼ぶ。
標準SQLに準拠した機能であるため、DBMSによらず利用することができる。
このタイプのテーブルは、決められたスパンにおいてしかデータを保持せず、
そのスパンが終了するとデータは（ユーザーがDELETE文を実行しなくても）自動的に削除される。
そのスパンは、トランザクションであったりセッションであったり、複数から選べる。
必要なときだけデータを保持して、使い終われば自動的に空になる、
名前のとおり「使い捨ての」テーブルというわけ。
ストレージ内容の節約になることもあって、比較的頻繁に使われている機能。

この一時テーブルは、「データマート」を作るために使われることもしばしば。
ビューと違って実データを保持するため、SELECT文のコストが上昇せず、
かといってマテリアライズドビューのように永続的にデータを保持するわけではないので、
ストレージの節約になるなど、利点は大きい。

一時テーブルにも欠点はある。しかも、かなり重大な欠点でもあるにもかかわらず、気付きにくいため、
一時テーブルのせいで苦しむことになるシステムも少なくない。
欠点は次の二つ。
欠点1 統計情報の収集タイミングが難しい。
欠点2 物理的なI/O分散が難しい。

欠点1 統計情報収集のタイミング
リレーショナルデータベースは、SQL文を実行するときに、テーブルやインデックスに含まれるデータの
統計情報をもちに実行計画（アクセスパス）を決定する。
この統計情報が古く、最新のデータ状態と乖離がある場合、最適な実行計画が作成されず、
性能問題の原因になる。
一時テーブルは、通常は空っぽで1行のレコードも持っていない。
したがってこの状態で統計情報を収集しても無意味。
一時テーブルの統計情報は、必要なデータがINSERTされた後に収集する必要がある。

一時テーブルにデータを入れるときは、すぐにそのデータを使いたいときが多いものだが、
入れてすぐ使えるわけではなく、統計情報収集という処理を一段にはさむことを前提に、
全体としての処理時間を計算しなければならない。


欠点2 一時テーブルの物理的なI/O分散
一時テーブルのもう一つの問題は、このテーブルI/O分散設計が難しいこと。
リレーショナルデータベースの情報は5種類のファイルによって管理されている。
①データファイル
②インデックスファイル
③システムファイル
④一時ファイル
⑤ログファイル

一時テーブルは二重の意味で性能的な問題を抱えている。
一時テーブルの使用そのものはグレーノウハウだとは言わないが、
「一時テーブルを使うときは、かなり性能的に厳しい条件下での設計が求められる」
ということを覚えておく。

勘どころ62
一時テーブルは性能的に不利な条件での戦いを強いられる。



第9章
一歩進んだ論理設計〜SQLで木構造を扱う

リレーショナルデータベースは強力な表現力を持ったデータベースだが、昔から扱うのが苦手な構造がある。
それが木構造。これは、長らくリレーショナルデータベースのアキレス腱。
この弱点をリレーショナルデータベースがどのように克服するか、その方法を明らかにする。


・リレーショナルデータベースには、表現することが苦手なデータ形式がある。
その代表格が、木（tree）構造。

・木構造を表現する伝統的な手段として、隣接リストモデルという方法があるが、
これはSQL文を複雑にする難しい方法。

・近年、隣接リストモデルに変わる新しい方法論が考えられる。

その方法論である、「入れ子集合モデル」およびそれを発展させた「入れ子区間モデル」
そして「経路列挙モデル」を学習する。


9-1
リレーショナルデータベースのアキレス腱
二次元表によくにた「テーブル」という形式（もともとtableという単語には「表」と言う意味もある）を
採用したリレーショナルデータベースは、その強力で便利な表現力を駆使して、ありとあらゆるシステムの
基幹データベースとして採用されるようになった。
今では、特に前置きなく「データベース」といえば、暗黙にリレーショナルデータベースを意味する。
二次元表は、生活の中で最もよく使う馴染み深い表現形式の一つなので、
人間にとっても直感的に理解しやすく便利。
誰にでも得意不得意というものはあるもの。リレーショナルデータベースは、幅広いオールラウンダー
ではあるが、それでもいくつかの苦手な相手を持っている。

木構造とは？
木構造のデータがそもそもどのようなものか、という点をはっきりさせておく。
木構造というのは、名前のとおり、データが「木」の形をしているような階層状の構造。
この構造は私たちの周りにもたくさんある。たとえば会社などの組織や、製品の部品同士の関係などは、
階層構造を持っている。

・ノード（node）
木の結節点のこと。

・ルートノード（root node）
木が始まるトップのノード。
「根っこ」と言う意味。木は、このルートノードを定義上一つしかもたない。

・リーフノード（leaf node）
自分よりも下位のノードを持たない「終着点」のノード。
「葉っぱ」と言う意味。

・内部ノード（inner node）
ルートでもリーフでもない中間のノードのこと。

・経路（path）
あるノードから別のノードへたどる道筋のこと。
「パス」と片仮名表記もする。


9-2
伝統的な解法〜隣接リストモデル
リレーショナルデータベースで木構造を扱う方法として、最も古くから知られている方法が、
隣接リストモデル（Adjacency List Model）。
これは、ノードのレコードに親ノードの情報（ポインタ）も持たせようとするもの。
このモデルは、SQLで木構造を表現する最も古く、かつポピュラーな方法。
そのため、DBMSベンダーが木構造を扱うための機能開発を行う際も、
基本的にこのモデルを前提にしている。

このモデルには、実用的な問題も指摘されている。
更新や検索のクエリが（ベンダー独自拡張を使わないと）極めて複雑になり、パフォーマンスも
悪いと言う欠点がある。
こうした欠点に対処し、標準SQLのみを使用して階層データの取り扱いを実現するために考案された
方法が、これから紹介する入れ子集合モデル。
このモデルは、隣接リストモデルとは対極的なアプローチを採用する。



9-3
新しい解法〜入れ子集合モデル
隣接リストモデルにおいては、各ノードは、文字通り結節「点」として考えられていた。
この「点」は、直径も面積も持たない。
一方、入れ子集合モデル（Nested Sets Model）は、ノードを点ではなく面積を持った
「円」としてとらえる。そして、ノード間の階層関係を円の包含関係によって表す。

勘どころ63
入れ子集合モデルでは、ノードを円と見なす。


入れ子集合モデルを使った検索
入れ子集合モデルの大きな利点は、木構造を操作するためのSQL文が、
隣接リストモデルに比べて非常にシンプルになる。


ルートとリーフを求める
木の操作で最も基本となるのは、ルートとリーフのノードを探すこと。
入れ子集合モデルでこれらを求めることは非常に簡単。
ルートは必ず左端の座標が1になる。

リーフとは、自分の中に他の円を一つも含まない円のこと。



木の深さを求める
残りの木の操作も、すべてこの「包含関係」の応用で記述することができる。
たとえば、あるノードの「深さ」（階層の位置）を求める場合は、
「自分を包含する円が何個あるか」という風に「包含関係」に翻訳すれば良い。


入れ子集合モデルを使った更新
入れ子集合モデルは、木構造の検索においては大きな力を発揮するが、一方で、
更新については問題を抱えている。


ノードの追加
ノードを追加する場合は、リーフとして追加するのか、親として追加するのかにって処理が分かれる。
基本はリーフを追加する場合を考えれば良い。

「更新対象と無関係な円の座標も連動して更新しなければならない」と言う点が、
入れ子集合モデルの最大の弱点。
これは動かす円の数が増えれば増えるほど、更新対象のレコードも増えるということなので、
データ量が多い場合には更新負荷とロック競合によって深刻なパフォーマンス問題を引き起こす。

勘どころ64
入れ子集合モデルの弱点は更新時のパフォーマンス


ノードの削除
リーフを削除する場合は、単純にそのレコードを削除するだけなので非常に簡単。
下位のノードも含めたノードを部分木と呼ぶ。
木の内部で新たにルートを見出して、小さな木とみなすイメージ。
この削除によって、座標に歯抜けの値が生まれたわけだが、これは特に更新しなくても問題ない。
入れ子集合では、座標の絶対値が重要なわけではなく、包含関係という相対的な関係が保持されていれば十分。
この、「相対関係さえ維持されていればOK」という考え方が、入れ子集合モデルの更新時のパフォーマンス問題を
解決する鍵となる。


9-4
もしも無限の資源があったなら〜入れ子区間モデル
入れ子集合モデルの欠点は、ノードを挿入する（追加）するときに、自分より「右側」にある
無関係なノードをもっと右へずらさなければならないこと。
このリソース枯渇の問題は、座標に整数を使う以上、原理的に不可避なもの。


使っても使っても尽きない資源
入れ子集合の左端/右端の座標に整数を使う必要はあるのか？
答えは「別にない」
キリのいい整数を使えば、図示した時に簡単に互いに円の関係がわかりやすい、というだけで、
実用的な観点から考えれば整数を使う必要は別にない。
座標のとれる範囲を整数から実数にまで広げることが、有効な解決策になる。

円の左端/右端の座標値として、とれる範囲を実数まで広げた、入れ子集合モデルの拡張版が、
入れ子区間モデル（Nested Intervals Model）。
実数は、定義上無限にある。かつ、どんな二つの実数の間にも無限にぎっしり詰まっている。
（この性質を稠密性（ちゅうみつせい）と呼ぶ）
どんなに隙間がないように見える二つの円の間であっても、新たに何個でも円を追加できる。
実数は、使っても使っても減らない、夢のようなリソース無限の世界。

勘どころ65
実数は汲めども尽きぬ無限の泉。


入れ子区間モデルを使った更新
入れ子区間モデルは、入れ子集合モデルの基本的な発想を踏襲しつつ、欠点を克服した
進化版のモデルということができる。


9-5
ファイルシステムとしての階層
勘どころ66
ノードをディレクトリ（フォルダ）と見なし、各ノードまでの経路（path）を記述する。


ディレクトリ（フォルダ）は、私たちがパソコンを使うときにファイルを入れておく仮想的な整理箱。
入れ子集合モデルでは、ノードを「円」に見立てる。
入れ子集合モデルでは、円の包含関係で階層を表現したのに対し、今度はパス文字列の包含関係で表現している。
経路列挙モデルの場合、子のパスが親のパスを含むという、入れ子集合とは反対の包含関係になっている。
ルートのパスは全てノードのパスの部分集合になっている。子たちは親たちの膨大な情報を受け継いでいく存在。


経路列挙モデルの利点と欠点
この経路列挙モデルの利点は、検索のパフォーマンスが良いこと。
ノード自身のレコードに親子関係が含まれているので、他のモデルに比べて経路探索のSQL文が圧倒的に簡単。
特に、正規表現を利用できるデータベースと、高い親和性を示す。
パフォーマンス面においても、パスもテーブル上で一意になるため、
ユニークインデックスによる高速検索が可能。

反対に欠点は、
・経路に主キーを使うと、経路の文字列が非常に長大になる危険がある（番号を使う場合にはこの心配は少ない）
  DBMSの可変長文字列の上限値を超えると、現実的な利用が難しい。

・経路に主キーを使うと、同じ階層内のノード同士の順序が一般的に把握できない
  （入れ子集合モデルでは、ノードの座標位置で示すことができた）
  ただし、番号を使うことで、この欠点は補える。

・パスに番号を使うと、ノードの削除、追加などの更新が複雑になる。

・検索SQLで文字列操作を多用するため、文字列関係の標準化が遅れているSQLでは、
  かなり実装依存のコードになってしまう。


こうした利点と欠点を総合して判断すると、更新が少なく、大量のデータの高速な検索が必要なケース
（たとえばDWH/BI）に向いているモデルと言える。

勘どころ67
経路列挙モデルは検索が簡単で更新が複雑。

主キーを使う場合と番号を使う場合、どちらの方法をとっても、経路の区切り文字が大変重要な役割を果たす。
パスの先頭と終端は必ず区切り文字で囲む必要がある。これは一見、些細なことに思えるかもしれないが、
これを囲むと囲まないとでは、更新クエリの効率に大きな違いが出るのです。


経路列挙モデルによる検索
ルートとリーフを探す
経路列挙モデルでのこうした検索はとても簡単。
経路に主キーを使っている場合は「区切り文字を削除した文字列がキーと同じになる」という条件で検索すれば良い。

REPLACEはほとんどのDBMSで利用できる標準関数で、第1引数の文字列の中から、
第2引数の文字列を見つけ出し、第3引数の文字列で置換する。

SQLの文字列操作の標準化が遅れているため、実装ごとに異なるコードを使わなければならないのが、
経路列挙モデルの欠点の一つ。


木の深さを求める
経路を直接データとして保持している利点が活きてくる。「経路」列に含まれる区切り文字を
数えれば、0を開始値とする深さが求められる。

区切り文字の数を数える方法は、「（元の文字列長）-（区切り文字を削除した文字列長）」
という引き算で可能。
「/アダム/セト/アベル/」（文字数=11）から「アダムセトアベル」（文字数=8）を引けば、区切り文字の数「3」が求められる。



経路列挙モデルを使った更新
検索に関してはいいことずくめの経路列挙モデルだが、その対価として更新処理は複雑になる。

ノードの追加
木にノードを追加するときは、リーフとして追加するのか、それとも親として追加するのかによって
処理が分かれる。リーフを追加するには、どの親ノードの配下に付けるかさえわかれば、
その親の経路に自分を追加すれば、自分の経路ができあがる。

親ノードとして追加するのはちょっと大変。新たに持つことになるこの数だけ処理を繰り返す
必要があるため、単発のSQLでは解決できない。


部分木の削除
部分木を削除することは、あるノードをルートに見立て、それにぶら下がるノードも一括して削除すること。
経路列挙モデルでは、あるノードが誰かの部下であれば、その上司の経路を必ず含んでいる。

まずサブクエリ内のSELECT文によって、削除対象となる部分木のルートの経路を求める。
残りの子ノード（自分も含めて）たちは、いずれもこの経路を前半に含む経路を持っているので、
LIKEの前方一致検索が使えるようになる。
経路が主キーでも番号でも使えて、かつサブクエリの内と外、どちらのSELECT文でも
インデックスが有効になるため、パフォーマンスも良好。


9-6
各モデルのまとめ

・隣接リストモデル
  最も古典的なモデル。検索/更新ともに複雑な処理を必要とする。
  DBMS依存の機能を使うことでこの欠点を軽減できるが、独自機能に頼ることになるため、汎用性がない。

・入れ子集合モデル
  木を円の包含関係によって表現するモデル。検索のSQLが簡単になるが、更新処理のパフォーマンスに問題を抱えている。

・入れ子区間モデル
  入れ子集合モデルの拡張版。入れ子集合モデルの欠点だった更新処理のパフォーマンス問題を克服できる。
  実数型の有効桁数が十分に確保されていなければ実用的ではない。

・経路列挙モデル
  ルートから各ノードまでの経路を保持するモデル。検索に強く更新に弱いのが特徴。


リレーショナルデータベースの論理設計といえば正規化と非正規化のせめぎあい、という印象が一般的。
しかしそれだけでは決着のつかない分野もある、ということ。
木構造とフラットな二次元表の相性が悪く、リレーショナルデータベースでは表現するに向かない構造。


演習問題
9-1
木構造を扱う4つのモデルが登場し、これらの正規形の次数は、それぞれいくつか。

・隣接リストモデル : 第5正規形
・入れ子集合モデル : 第3正規形
・入れ子区間モデル : 第3正規形
・経路列挙モデル : 第3正規形

どのモデルのテーブルにおいても、部分関数従属も推移的関数従属もないため、
第3正規形は満たしている。
隣接リストモデルは、非キー列からキー列への関数従属はないため、ボイスーコッド正規形も満たしている。
そもそも多値従属も存在しないため、第4と第5正規形も満たしている。




9-2
実数のデータ型
入れ子区間モデルの「左端」および「右端」の列を実装するためのデータ型を
DBMSの最新バージョンについて調べる。

いずれのDBMSもREAL型という実数を格納するためのデータ型を持っている。
厳密な実数値を格納できるわけではなく（実数は無限小数を含むのでそれは不可能）、
あくまで近似的な概数型。論理は、物理の制約から自由ではない。

