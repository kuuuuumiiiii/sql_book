第1部
SQLをはじめよう

第1章
はじめてのSQL

1.1
データベースとは
検索や書き換え、分析などのデータ管理を目的として蓄積された、さまざまな情報そのものを指す
ITの世界では、電子的な媒体にファイルなどの形式で保存したものをいう

分野を問わず広く用いられているのが、複数の表の形式でデータを管理するリレーショナルデータベースです

RDBの基本構造
個々の表をテーブルという
テーブルの名前をテーブル名という
テーブルは行（row）と列（column）で構成される
行をレコード、列をカラムやフィールドと呼ぶ


データベースの中のデータを操作するには、データベースファイルではなく、データベース管理システムと呼ばれるプログラムに対して、
SQLで書かれた命令文（SQL文）を送信する。


1.2
はじめてのSQL
SELECTには目的とする列名を、FROMには検索したいテーブル名を記述する。

全ての列を取得するときに使える簡略化
「*」 には「全ての列」という意味がある

WHERE
検索条件を指定する

３命令の動作
SELECT : ある条件を満たす行を探す => その行の内容を取得する
UPDATE : ある条件を満たす行を探す => その行の内容を書き換える
DELETE : ある条件を満たす行を探す => その行を削除する


1.4
練習問題
1-1
（A）ファイル （B）DBMS （C）SQL文 （D）リレーショナルデータベース （E）カラム （F）レコード

1-2
SNS => 投稿、フォロワー

1-3
1.入金額が50000円に等しい行を検索してすべての列を表示する
SELSECT *
FROM 家計簿
WHERE 入金額 = 50000

2.出金額が4000円を超える行を全て削除する
DELETE FROM 家計簿
WHERE 出金額 > 4000

3.2022年2月3日のメモを「カフェラテを購入」に変更する
UPDATE 家計簿
  SET メモ = 'カフェラテを購入'
  WHERE 日付 = '2022-02-03'


第2章
基本文法と４大命令

SQL基本ルール
・文の途中に改行を入れることができる
・行の先頭や行の途中に半角の空白を入れることができる

SQL基本ルール2
・ハイフン2つ（--）から行末まではコメントとして扱われる
・/* から */まではコメントとして扱われる

SQL基本ルール3
・SELECTやWHEREなどの命令の使う単語は、SQLとして特別な意味を持つ「予約語」である。
・予約語は、大文字と小文字のどちらで記述してもよい
・テーブル名や列名に予約語を利用することはできない

列名やテーブル名について、大文字と小文字を区別するかどうかは、DBMS製品や動作するOS、設定などによって異なる


2.2
データ型とリテラル

リテラルの記述に関するルール
・「’」でくくらずに記述されたリテラルは、数値情報として扱われる
・「’」でくくられたリテラルは、基本的に文字列情報として扱われる
・「’」でくくられ、'2022-02-25'のような一定の形式で記述されたリテラルは、日付情報として扱われる

プログラミング言語で文字列を表すダブルクォーテーション記号は、SQLの文字列リテラルとして用いることができない。


型とデータ型
データベースの中には複数のテーブルがあり、テーブルは行と列から成り立っている。それぞれの列には名前がついているが、
それに加えて、列ごとに格納できるデータの種類を表すデータ型を定めることになっている。


データ型
・テーブルの各列には、データ型が指定されている。
・列には、データ型で指定された種類の情報しか格納することができない
・利用可能なデータ型は、DBMS製品によって異なる


CHAR型は固定長の文字列を扱うデータ型。
CHAR(10)と指定されている列では、あらかじめ10バイトの領域が確保されていて、格納するデータは常に10バイトになる。
10バイト以下の場合は、文字列の後に空白が追加されて、10バイトぴったりに調整されてから格納される。

VARCHAR型を指定された列は、格納する文字列の長さを勝手に調整することはない。
VARCHAR(10)と指定された列に3バイトや7バイトの文字列を登録した場合、それに合わせた領域が確保されるため、そのままの長さで格納される。
最大長として10が指定されているので、11バイトの文字列は格納できない。


2.3
4つの重要なSQL文
ほとんどのデータ操作は、SELECT,UPDATE,DELETE,INSERTのたった4つの命令で実現できてしまう。
これらの4つのSQL命令は、DML（Data Manipulation Language）と総称されている。
これらを４大命令と呼ぶ


2.4
SELECT文データの検索
SELECT文の基本構文

ASによる別名の定義
SELECT文における列名やテーブル名の指定では、それぞれの記述の後ろにASと任意のキーワードをつけることで、別名を定義することができる。

列に別名を付けるメリット
・結果表における例のタイトルを状況に応じて任意の内容で表示できる
・英語名などの一見わかりにくい列名や長い列名でも、わかりやすく短い別名をつけれSQL文の中で利用することができる


2.5
UPDATE文の基本構文
UPDATE文は、すでにテーブルに存在するデータを書き換えるための命令文
UPDATEの直後に、更新したいデータが存在するテーブル名を記述し
2行目をSET句といい、更新したい列名と、その列に書き込むデータをイコール記号で対応させて記述する

ある特定の行のみを書き換えたい場合はWHEREを使って目的の行を指定する

WHEREを使わないUPDATE文はほとんど存在しない
WHEREのないUPDATE文は全件更新されてしまう

2.6
DELETE文の基本構文
DELETE文は、すでにテーブルに存在する行を削除するための命令。
既存のデータに対する操作という点では、これまでに登場したSELECT文やUPDATE文と同じですが、行をまるごと削除する機能であるため、
特定の列だけを指定するようなことはできない

DELETE文では列名を指定する必要がないので、DELETEの後には何も記述しない。続けて記述するFROM句にテーブル名を指定するのは
SELECT文と同様

WHEREを指定しなければ、すべての行が削除対象となってしまう


2.7
INSERT文の基本構造
INSERT文は、テーブルに新しいデータを追加するための命令。
これまでに紹介した3つの命令とは異なり、テーブルの行を指定するしくみはない。
そのかわり、どこに、どのようなデータを追加するのかを指定する必要がある構造になっている。


2.8
4大命令をスッキリ学ぶ

4大命令をスッキリ学ぶ3つのコツ
1,4大命令の構造と修飾語の全体像をしっかり把握する
2,4大命令の2通りの分類方法を理解する
3,4大命令に共通するテーブル指定を先に書く


4大命令の2通りの分類を理解する
SELECT,UPDATE,DELETE,INSERTの4つを2つのグループに分類する

4大命令の分類方法（1） 検索系と更新系
検索系: SELECT
更新系: UPDATE,DELITE,INSERT

検索系の命令はデータベースのデータを書き換えることはない。また、実行結果は表の形になる。
一方、更新系の命令はデータベースのデータを書き換えることが仕事
実行結果は基本的に「成功」か「失敗」かの2つに1つであり表などが返されることはない


4大命令の分類方法（2） 既存系と新規系
既存系: SELECT,UPDATE,DELETE
新規系: INSERT

既存系の命令は、すでにデータベースに存在するデータに対してなんらかの処理を行うためのもの
一方、新規系の命令は、まだデータベースに存在しないデータについての指定をする

4第命令のすべてに共通すること
処理対象とするテーブル名を必ず指定する必要がある


スッキリ書けるSQL
1,まず、命令（SELECT,UPDATE,DELETE,INSERT）を記述する
2,次に、テーブル指定の部分を記述する
3,テーブル指定より後の部分を記述する
4,テーブル指定より前の部分を記述する（SELECT文のみ）





2.9
SQLの基本ルール
・記述の途中で改行したり、半角の空白を入れたりしてもよい
・予約語は大文字、小文字が区別されない。また、列名などに利用できない
・文中にコメントを記述することができる

データ型とリテラル
・SQL文の中に直接記述される具体的な値をリテラルという
・数値、文字列、日付など、データの種類に応じてリテラルの記述方法は異なる
・テーブルの各列にはデータ型が指定されている
・列に指定された種類のデータのみ、その列に格納することができる

SQLの体系
・SELECT,UPDATE,DELETE,INSERTの4つの命令を利用する
・各命令をどのように実行するかを指示する修飾が豊富に用意されており、組み合わせることによって多様な命令を実現できる
・4つの命令は、操作内容から見た検索系と更新系、対象とするデータから見た既存系と新規系に分類することができる

4大命令をスッキリ学ぶコツ
・4大命令の構造と修飾語の全体像をしっかり把握する
・4大命令の2通りの分類方法を理解する
・4大命令に共通するテーブル指定を先に書く

2.10
練習問題
2-1
（A）SELECT（B）UPDATE（C）DELETE（D）INSERT（E）FROM（F）FROM（G）INTO（H）WHERE

2-2
（1）INTEGER
（2）VARCHAR
（3）DATE
（4）DECIMAL
（5）TIME
（6）INTEGER
（7）CHAR

2-3
1.すべての列名を明示的に指定して、すべての行を取得する
SELECT コード, 地域, 都道府県名, 県庁所在地, 面積
  FROM 都道府県

2.列名の指定を省略して、1.と同様の結果を取得する
SELECT *
  FROM 都道府県

3.「地域」「都道府県名」の列について、「area」「pref」という名前を付けてすべての行を取得する
SELECT 地域 AS area, 都道府県 AS pref
  FROM 都道府県


2-4
1.
INSERT INTO 都道府県(コード, 地域, 都道府県名, 面積)
  VALUES ('26', '近畿', '京都', 4613)

2.
INSERT INTO 都道府県
  VALUES ('37', '四国', '香川', '高松', 1876)

3.
INSERT INTO 都道府県(コード, 都道府県, 県庁所在地)
  VALUES ('40', '福岡', '福岡')

2-5
1.コード26の県庁所在地に「京都」を格納する
UPDATE 都道府県
  SET 県庁所在地 = '京都'
  WHERE コード = '26'

2.コード40の地域に「九州」、面積に4976を格納する
UPDATE 都道府県
  SET 地域 = '九州', 面積 = 4976
  WHERE コード = '40'

2-6
DELETE 
  FROM 都道府県
  WHERE コード = '26'


3.1
WHERE句による絞り込み

WHERE句の大切さ
SQLの言語としての特徴
命令自体は単純で、数も少ない（主に使うのは4つ）
しかし、さまざまな修飾語を付けることで、複雑な処理が可能になる

WHERE句を使って「テーブルのどの行を処理したいのか」を指定する
WHERE句を伴わないSQL文を使うことのほうが少ない

WHERE句の基本
1,処理対象行の絞り込みに用いる
  =>WHEREを指定しないと「すべての行」が対象になる
2,SELECT,UPDATE,DELETE文で使用可能
  =>新しい行を追加するINSERT文では使用でいない
3,WHEREの後には条件式を記述する
  =>絞り込み条件に沿った「正しい条件式」を記述する





3.2
条件式
真と偽
条件式とは、その結果が必ず真か偽になる式のこと

WHERE句に書けるもの
結果が必ず真（true）または偽（false）となる条件式

WHERE句のしくみ
WHERE句を含むSQL文を受け取ったDBMSは、テーブルのすべての行について条件式が真になるかをそれぞれ調べる
そして、真になった行についてのみ、SELECT,UPDATE,DELITEなどの処理を行う



3.3
さまざまな比較演算子

条件式は、=（等号）や<（不等号）のような記号を含んだ式になることがほとんど
これらの記号は比較演算子といい、その記号の左右にある値を比較して、記号の意味が正しければ真、正しくなければ偽に「化ける」
役割をもっている。

主な比較演算子
= 左右の値が等しい
< 左辺は右辺より小さい
> 左辺は右辺より大きい
<= 左辺は右辺の値以下
>= 左辺は右辺の値以上
<> 左右の値が等しくない


NULLの判定
どのような値も格納されていない状態を意味するNULLという特別なもおんいなることがある

NULLの2種類の意味
1,格納すべきデータが不明なとき
2,データを格納すること自体が無意味なとき


NULLとは
・そこに何も値が格納されていない状態を意味する、特別なもの
・数値のゼロや空白文字、長さのゼロの文字列とも異なる存在である
・格納データが「不明」や「無意味」である状況を示す意図で用いられる

条件式でNULLであることを判定するためには IS NULL演算子、NULLでないことを判定するためには IS NOT NULL演算子を使う

NULLの判定
・NULLであることを判定する
  式 IS NULL

・NULLでないことを判定する
  式 IS NOT NULL


NULLは=で判定できない
NULLは=や<>では判定できない。必ずIS NULLやIS NOT NULLを使って条件式を作ること


LIKE演算子
文字列があるパターンに合致しているかをチェックすることをパターンマッチングという
SQLではこのパターンマッチングにLIKE演算子を使う

LIKE演算子によるパターンマッチング

パターン文字列に用いると特別な意味を持つ文字には、主に次のようなものがある
% => 任意の0文字以上の文字列
_ => 任意の1文字


「100%」という文字で終わるかを判定したい場合のように、%や_の文字そのものを含む文字列を一部一致検索したいときには、少し工夫が必要
なぜなら、次のようにそのまま記述すると、%はパターン文字として扱われてしまうから

「100を含む文字列」という意味になる
SELECT *
  FROM 家計簿
  WHERE メモ
  LIKE '%100%'

パターン文字列の中で、単なる文字として%や_を使いたい場合、次のようにESCAPE句を併用した記述を行う
SELECT *
  FROM 家計簿
  WHERE メモ
  LIKE '%100$%'
  ESCAPE '$'


BETWEEN演算子
BETWEEN演算子は、ある範囲内に値が収まっているかを判定する

BETWEEN演算子では、データが「値1以上かつ値2以下」の場合に真になる
データがちょうど値1や値2の場合も真になる点に注意


IN / NOT IN演算子
IN演算子は、カッコ内に列挙した複数の値（値リスト）のいずれかにデータが合致するかを判定する演算子
= 演算子では、1つの値との比較しかできないが、IN演算子を使えば、一度にたくさんの値との比較が可能

カッコ内に列挙した値のどれとも合致しないことを判定するには、
NOT IN演算子を使う

ANY / ALL 演算子
複数の値と「大小」を比較したい場合には、ANY演算子やALL演算子を利用する。
ANYやALLでは、必ずその直前に比較演算子を付けて、どのような比較を一度に行うのかを指定する

ANY / ALL演算子による複数値との比較
・値リストのそれぞれと比較して、いずれかが真なら真

同じ意味になる演算子
・NOT INと<>ALLはどの値とも一致しないことを判定する演算子
・IN と = ANYはいずれかの値と一致することを判定する演算子


3.4
複数の条件式を組み合わせる
1つの条件式ではうまく行を絞り込めない場合、論理演算子を用いて、複数の条件式を組み合わせることができる
代表的な論理演算子には、AND演算子とOR演算子がある

AND演算子とOR演算子
・2つの条件式の両方が真の場合だけ、真となる（AかつB）
・2つの条件式のどちらかが真ならば、真となる（AまたはB）

ANDとORは、両辺に条件式を必要とする演算子
一方、右辺しか必要としないNOT演算子も存在する。NOT演算子は、条件式の結果について、真は偽に、偽は真に逆転させる性質をもっている


論理演算子の優先度
理論演算子で条件式を組み合わせる際は、演算子が評価される優先順位に注意を払う必要がある
複数の論理演算子が使われている場合では、1,NOT 2,AND 3,OR の優先順位に従って処理されていく
特にANDとORの優先順位についてはしっかり覚えておく

カッコによる優先順位の引き上げ
条件式をカッコでくくると、評価の優先順位が上がる


3.5
主キーとその必要性

テーブルの中に重複した行が格納されるようなことは避けるべき

社員テーブルにおける社員番号のように、「この値を指定することで、ある1行を完全に特定できる」という役割を担う列のことを、特に主キーという

主キーとなる列が持つべき特性
・必ず何らかのデータが格納される
・ほかの行と値が重複しない
・一度決めた値は変化しない

私たちがデータベースで情報を管理する場合、ある特定の行を削除したり更新したりする操作は頻繁に発生する
従って、あらゆる行をいつも自由にWHERE句で特定できるためにも、すべてのテーブルは主キーとなる列を必ず持つべき


主キー列を作り出す
管理目的のためだけに人偽的に追加された列を、自然キーに対して人工キーや代替キーという


複数の列で行を識別する
単独では重複の可能性がある列でも、複数の列を組み合わせれば重複する可能性が実質的になくなる場合がある
複数の列を1つの主キーとして扱うものを複合主キーという


3.6
この章のまとめ
WHERE句
・WHERE句は、SELECT,UPDATE,DELRETE文で使うことができる
・WHERE句に記述した条件式によって、対象データを絞り込むことができる
・条件式で真に評価されるデータが処理の対象になる

演算子
・条件式にはさまざまな演算子を記述できる
  比較演算子: =, <, >,<=, >=, <>,IS NULL, LIKE, BETWEEN, IN, ANY, ALL
  論理演算子: AND, OR, NOT
・論理演算子は、NOT, AND, ORの順で優先度が高く、先に評価される

NULL
・NULLは、値が不明または無意味であるためにデータが格納されていない状態を表す
・NULLを判定するための条件式では、IS NULLとIS NOT NULLを使用する
「= NULL」では正しく判定できない

主キー
・主キーによって、テーブル内の1つひとつの行が識別可能になる
・主キーとなる列には、重複しない値が必ず格納される必要がある
・自然キーが存在しない場合は、人工キーを追加して識別可能にする
・複数の列を組み合わせて複合主キーを構成し、行を識別するために用いることができる


3.7
練習問題

3-1
1.6月のデータ
SELECT *
  FROM 気象観測
  WHERE 月 = 6

2.6月以外のデータ
SELECT *
  FROM 気象観測
  WHERE 月 <>

3.降水量が100未満のデータ
SELECT *
  FROM 気象観測
  WHERE 降水量 < 100

4.降水量が200より多いデータ
SELECT *
  FROM 気象観測
  WHERE 降水量 > 200

5.最高気温が30以上のデータ
SELECT *
  FROM 気象観測
  WHERE 最高気温 >= 30

6.最低気温が0以下のデータ
SELECT *
  FROM 気象観測
  WHERE 最低気温 <= 0

7.3月、5月、7月のデータ
SELECT *
  FROM 気象観測
  WHERE 月 IN (3, 5, 7)

8.3月、5月、7月以外のデータ
SELECT *
  FROM 気象観測
  WHERE 月 NOT IN (3, 5, 7)

9.降水量が100以下で、湿度が50より低いデータ
SELECT *
  FROM 気象観測
  WHERE 降水量 <= 100 AND 湿度 < 50

10.最低気温が5未満か、最高気温が35より高いデータ
SELECT *
  FROM 気象観測
  WHERE 最低気温 < 5 OR 最高気温 > 35

11.湿度が60~79の範囲にあるデータ
SELECT *
  FROM 気象観測
  WHERE 湿度 BETWEEN 60 AND 79

12.観測データのない列のある月のデータ
SELECT *
  FROM 気象観測
  WHERE 降水量 IS NULL OR 最高気温 IS NULL
    OR 最低気温 IS NULL OR 湿度 IS NULL


3-2
1.都道府県名が「川」で終わる都道府県名
SELECT 都道府県名
  FROM 都道府県
  WHERE 都道府県名 LIKE '%川'


2.都道府県名に「島」が含まれる都道府県名
SELECT 都道府県名
  FROM 都道府県
  WHERE 都道府県名 LIKE '%島%'

3.都道府県が「愛」で始まる都道府県名
SELECT 都道府県名
  FROM 都道府県
  WHERE 都道府県名 LIKE '愛%'

4.都道府県と県庁所在地が一致するデータ
SELECT *
  FROM 都道府県
  WHERE 都道府県名 = 県庁所在地

5.都道府県と県庁所在地が一致しないデータ
SELECT *
  FROM 都道府県
  WHERE 都道府県名 <> 県庁所在地


3-3
1.登録されている全データを取得し、テーブルの内容を確認する
SELECT *
  FROM 成績表

2.学生の成績データを追加する
INSERT INTO 成績表
  VALUES ('S001', '織田 信長', 77, 55, 80, 75, 93, NULL);

INSERT INTO 成績表
  VALUES ('A002', '豊臣 秀吉', 64, 69, 70, 0, 59, NULL);

INSERT INTO 成績表
  VALUES ('E003', '徳川 家康', 80, 83, 85, 90, 79, NULL);

3.2で登録した学籍番号S001の学生の法学を85、哲学を67に修正する
UPDATE 成績表
  SET 法学 = 85, 哲学 = 67
  WHERE 学籍番号 = 'S001'

4.2で登録した学籍番号A002の学生と学籍番号E003の学生の外国語を81に修正する
UPDATE 成績表
  SET 外国語 = 81
  WHERE 学籍番号 IN ('A002', 'E003')

5.次のルールで総合成績を更新する
(1)全科目が80点以上の学生は「A」とする
UPDATE 成績表
  SET 総合成績 = 'A'
  WHERE 法学 >= 80 AND 経済学 >= 80 AND 哲学 >= 80 AND 情報理論 >= 80 AND 外国語 >= 80

(2)法学と外国語のどちらかが80以上、かつ経済学と哲学のどちらかが80以上の学生は「B」とする
UPDATE 成績表
  SET 総合成績 = 'B'
  WHERE (法学 >= 80 OR 外国語 >= 80)
  AND (経済学 >= 80 OR 哲学 >= 80)
  AND 総合成績 IS NULL

(3)全科目が50未満の学生は「D」とする
UPDATE 成績表
  SET 総合成績 = 'D'
  WHERE 法学 < 50 AND 経済学 < 50 AND 哲学 < 50 AND 情報理論 < 50 AND 外国語 < 50
  AND 総合成績 IS NULL

(4)それ以外の学生を「C」とする
UPDATE 成績表
  SET 総合成績 = 'C'
  WHERE 総合成績 IS NULL

6.いずれかの科目に0がある学生を、成績表テーブルから削除する
DELETE FROM 成績表
  WHERE 法学 = 0
  OR 経済学 = 0
  OR 哲学 = 0
  OR 情報理論 = 0
  OR 外国語 = 0


3-4
1.月
2.コード
3.在籍番号




第4章
検索結果の加工

4.1
検索結果の加工

SELECT文だけに可能な装飾

検索結果を加工する主なキーワード
DISTINCT  検索結果から重複行を除外する
ORDER BY  検索結果の順序を並べ替える
OFFSET -FETCH  検索結果から件数を限定して取得する
UNION  検索結果にほかの検索結果を足し合わせる
EXCEPT  検索結果から他の検索結果を差し引く
INTERESECT  検索結果とほかの検索結果で重複する部分を取得する


4.2
DISTINCT -重複行を除外する

DISTINCTキーワードをSELECT文の選択リストの前に記述すると、結果表の中で内容が重複している行があれば、その重複を取り除いてくれる

SELECT DISTINCT 列名…
  FROM テーブル名

DISTINCT修飾は、他の修飾キーワードと異なり、SELECT文の最初に記述する必要がある


4.3
ORDER BY -結果を並べ替える

並び替えの基本
SELECT文の最後にORDER BY句を記述すると、指定した列の値を基準として並び変えた検索結果を取得することができる

SELECT 列名…
  FROM テーブル名
  ORDER BY 列名 並び順

  ※並び順は、ASC（昇順、最小値が先頭）またはDESC（降順、最大値が先頭）
  並び順の省略をすると昇順になる


ショッピングサイトの「売れ筋ランキング」表示なども、内部でORDER BYを使っている

複数の列を基準にした並び替え
ORDER BY句による並び替えの際、複数の列をカンマで区切って指定することができる。
このような指定を行うと、最初に指定された列で並べ替えて同じ値が複数行あれば、次に指定された列で並び替えが行われる。
例えば、「原則として入金額の降順で並べ替える。入金額が等しい行については、さらに出金額の降順で並べ替える」という指定をするには
下記のようなSQLを記述する

SELECT *
  FROM 家計簿
  ORDER BY 入金額 DESC, 出金額 DESC


列番号を指定した並び替え
ORDER BY句では並び替えの基準とする列を列名ではなく列番号で指定することも可能
列番号とは、選択列リストにおける列の番号のことで、SELECT命令に記述した順に1から数える。

SELECT *
  FROM 家計簿
  ORDER BY 4 DESC, 5 DESC

このように、テーブルの全列を指定する「*」を選択列リストに使った場合も、実際に取得の対象となる列に置き換えた列番号を指定する
ORDER BY句における列指定に列番号を用いる場合、SELECT文の選択列リストの記述を修正すると並び替えの結果にも影響が及ぶ点に注意

ORDER BY句を伴わない場合、DBMSはどのような順序で行を返すか保証していない。
同じSEKECT文でも実行のたびに結果表に含まれる行の順序が変わることもあり得るため、
「必ずこの順番で並べた結果がほしい」とう場面では、ORDER BY句を忘れずに記述する


4-4
OFFSET -FETCH -行数を限定して取得する

一部の行だけを得る
検索気かの全行ではなく、並べ替えた結果の一部の行だけを得られればよいケースもある。そのような場合、ORDER BY句に続けて
OFFSET -FETCH句を付けることによって簡単に実現できる

行数を限定して取得する
SELECT 列名…
  FROM テーブル名
  ORDER BY 列名…
  OFFSET 先頭から除外する行数 ROWS
  FETCH NEXT 取得行数 ROWS ONLY

OFFSET句には、先頭から除外したい行数を記述する。除外せずに1件目から取得したい場合には0を指定するか、
DBMSによってはOFFSET句自体を省略できる。
FETCH句には、取得したい行数を指定する。FETCH句を省略すると、該当するすべての行が抽出される。
たとえば、結果の11~15番目の行だけを取得したい場合は、OFFSET句に10,FETCH句に5を指定することになる。


4.5
集合演算子
集合演算子とは
構造がよく似た複数のテーブルにSELECT文をそれぞれ送り、その結果を組み合わせたい場合は、
集合演算子を活用して1つのSQL文で目的を達成することができる。
集合演算とは、SELECT命令によって抽出した結果表を1つのデータの集合と捉え、その結果同士を足し合わせたり、共通部分を探したり
というような演算を行なってくれる仕組み


UNION
和集合 2つの検索結果を足し合わせたもの

EXCEPT(MINUS)
差集合 最初の検索結果から次の検索結果と重複する部分を取り除いたもの

INTERSECT
積集合 2つの検索結果で重複するもの

UNION -和集合を求める
UNION演算子は、最も代表的な集合演算子です。2つのSELECT文をUNIONでつないで記述すると、
それぞれの検索結果を足し合わせた結果（和集合）が返される

2つのSELECT文の結果を足し合わせる
SELECT 文1
  UNION (ALL)
  SELECT 文２

また、和集合の結果に重複行があった場合の動作として、UNION単独では重複行を1行にまとめるのに対し、
UNION ALLでは重複行をまとめずにそのまま返す

集合演算子を使える条件
SELECTの結果を集合演算子でまとめるときは、選択列リストの列数とそれぞれのデータ型が一致していなければならない


集合演算子でORDER BY句を使う時の注意点
・ORDER BY句は最後のSELECT文に記述する
・列番号以外による指定（列名やASによる別名）の場合、1つ目のSELECT文に記述したものを指定する


EXCEPT / MINUS -差集合を求める
差集合は、ある集合と別の集合の差。
あるSELECT文の検索結果に存在する行から、別のSELECT文の検索結果に存在する行を差し引いた集合となる。
差集合を得るには、EXCEPT演算子を用いる。

2つのSELECT文の結果の差を得る
SELECT 文1
  EXCEPT (ALL)
  SELECT 文2

EXCEPT ALLは、重複した行を1行にまとめずにそのまま返す。
差集合を求める場合は、SELECT文を記述する順番に注意が必要。
差集合はどの集合を基準とするかによって結果が変わってくる。
これは1+2と2+1の結果は同じでも1-2と2-1の結果は異なるのと同様。

INTERSECT -積集合を求める
INTERSECT演算子で求めることができる積集合とは、2つのSELECT文に共通する行を集めた集合。

積集合を求める
SELECT 文1
INTERSECT
SELECT 文2

積集合は和集合と同じく、どの順番でSELECT文を記述しても結果は変わらない。
また、INTERSECTにALLキーワードを付けると、積集合から重複した行をまとめずにそのまま返す。


4.6
この章のまとめ

検索結果の加工
・SELECT文で取得したデータは、以下のような様々な形に加工できる。

DISTINCT  重複行を除外する

ORDER BY  結果を並び替える

OFFSET -FETCH  行を限定して取得する

UNION, EXCEPT/MINUS, INTERSECT  結果を集合演算する


・DBMSによって、使うことのできる機能やキーワードが異なる場合がある。

集合演算子
・集合演算子は、複数のSELECT文の結果を使って集合演算を行う。
・UNIONは和集合、EXCEPT/MINUSは差集合、INTERSECTは積集合を求める。
・集合演算子を用いるには、列数とデータ型を一致させるひつようがある。
・集合演算子とORDER BY句を併用する際の制限に注意する。


4.7
練習問題

1.注文順かつその明細順に、すべての注文データを取得する
SELECT *
  FROM 注文履歴
  ORDER BY 注文番号, 注文枝番

2.2022年1月に注文のあった商品名の一覧を商品名順に取得する
SELECT DISTINCT 商品名
  FROM 注文番号
  WHERE 日付 >= '2022-01-01' AND 日付 <= '2022-01-31'
  ORDER BY 商品名

3.ドリンクの商品を対象に、注文金額の低いほうから2~4番目の注文の注文番号と注文枝番、注文金額を取得する
SELECT 注文番号, 注文枝番, 注文金額
  FROM 注文履歴
  WHERE 分類 = '1'
  ORDER BY 注文金額
  OFFSET 1 ROWS FETCH NEXT 3 ROWS ONLY

4.その他の商品について、2つ以上同意に購入された商品を取得し、日付、商品名、単価、数量、注文金額を購入日順に表示する。
ただし、同日に売り上げたものは、数量の多い順に表示する
SELECT 日付, 商品名, 単価, 数量, 注文金額
  FROM 注文履歴
  WHERE 分類 = '3' AND 数量 >= 2
  ORDER BY 日付, 数量 DESC

5.商品の分類ごとに、分類、商品名、サイズ、単価を1つの表として取得する。
また、サイズはドリンクの商品についてのみ表示し、分類と商品名順に並べる。
SELECT DISTINCT 分類, 商品名, サイズ, 単価
  FROM 注文履歴
  WHERE 分類 = '1' UNION
SELECT DISTINCT 分類, 商品名, NULL, 単価
  FROM 注文履歴 WHERE 分類 = '2' UNION
SELECT DISTINCT 分類, 商品名, NULL, 単価
  FROM 注文履歴 WHERE 分類 = '3'
  ORDER BY 1, 2


4-2
-10~10の範囲にある自然数、整数、奇数、偶数がそれぞれ登録されている4つのテーブルがある
4つのテーブルから2つを選び、集合演算子によって組み合わせてSQLを作成する

1.和集合の結果、整数テーブルと等しくなる
SELECT 値
  FROM 奇数 UNION
SELECT 値
  FROM 偶数

2.差集合の結果、奇数テーブルと等しくなる
SELECT 値
  FROM 整数 EXCEPT
SELECT 値
  FROM 偶数

3.積集合の結果、偶数テーブルと等しくなる
SELECT 値
  FROM 整数 INTERSECT
SELECT 値
  FROM 偶数

4.検索結果なし
SELECT 値
  FROM 奇数 INTERSECT
SELECT 値
  FROM 偶数



第２部
SQLを使いこなそう

第5章
式と関数

式と演算子

選択列リストで計算式を使う
選択列リストに計算式や固定値を使うと、その計算式や固定値がそのまま結果表の列名になってしまう。
このような表示が好ましくない場合はASで命名してあげる。


データの代わりに計算式を使う
INSERT文やUPDATE文でテーブルに書き込む具体的な値の代わりに式を指定すること。


式が評価されるしくみ

DBMSによる処理の原則
・DBMSは、テーブル内の各行を1つずつ順番に処理していく
・式の評価なども、各行で行われている

DBMSは、「1行に注目しては、出金額を計算して更新する」という処理を、行数の分だけ繰り返している
DBMSが式を評価するときには、常にいずれか1行だけに注目している


5.2
さまざまな演算子

基本的な算術演算子
+演算子以外にも、SQLにはさまざまな演算子が用意されている

数値+数値 数値同士で足し算をする
日付+数値 日付を指定日数だけ進める

数値-数値 数値同士で引き算をする
日付-数値 日付を指定日数だけ戻す
日付-日付 日付の差の日数を得る

数値*数値 数値同士で掛け算をする

数値/数値 数値同士で割り算をする（整数同士の場合は商が返される）

文字列||文字列 文字列を連結する（文字列連結には+演算子を利用するDBMSもある）

+演算子や-演算子は、数値の計算以外にも利用できる。日付の計算や、DBMSによっては文字列の連結ができる


CASE 演算子 -値を変換する
代表的な算術演算子のほかに、特殊な演算子
CASE演算子は、例の値や条件式を評価し、その結果に応じて値を自由に変換してくれる。

CASE 演算子の利用構文（1）
CASE 評価する列や式  WHEN 値1 THEN 値1のときに返す値
                  (WHEN 値2 THEN 値2のときに返す値)
                  (ELSE デフォルト値)
END


CASE 演算子の利用構文（2）
CASE WHEN 条件1 THEN 条件1のときに返す値
     (WHEN 条件2 THEN 条件2の時に返す値)
     (ELSE デフォルト値)
END


5.3
さまざまな関数

関数とは
すべての関数は「呼び出し時に指定した情報（引数）に対して、定められた処理を行い、結果（戻り値）に変換に変換する」という動作をします。
たとえば、LENGTHという関数は、ある文字列をその文字列の長さ（文字数など）に変換する機能を持っている

関数の使い方

関数について定められていること
名前 :その関数の名前
引数 :その関数を呼び出す際に引き渡す情報（関数によっては2つ以上の場合もある）
戻り値 :その関数の呼び出し結果として得られる情報

LENGTH関数の仕様
名前 :LENGTH
引数 :文字列が格納された列（または式）
戻り値 :文字列の長さを表す数値


関数が動作する流れ
関数の呼び出しも各行ごとに繰り返し行われている。
関数の呼び出しの記述は、呼び出し完了後に戻り値に「化ける」

関数はDBMSによって大きく異なる
関数は、DBMS製品によって構文や機能が大きく異なるため、詳細は製品マニュアルを参照する必要がある

5.4
文字列にまつわる関数

LENGTH/LEN -長さを得る
LENGTH関数は、文字列の長さを調べてくれる関数。
テーブルの列に格納されている文字列の長さを取得したい、取得した長さを使って検索や更新をしたい
などの場合に利用する

文字列の長さを得る関数
LENGTH（文字列を表す列） => 文字列の長さを表す数値
結果は文字数またはバイト数で得られる

TRIM -空白を除去する
ある文字列の前後についている、余計な空白を除去したい場合に便利な関数がTRIM関数
類似する機能を持つLTRIM関数やRTRIM関数がある

空白を除去する関数
TRIM（文字列を表す列）=> 左右から空白を除去した文字列
LTRIM（文字列を表す列）=> 左側の空白を除去した文字列
RTRIM（文字列を表す列）=> 右側の空白を除去した文字列


REPLACE -指定文字を置換する
REPLACE関数は、文字列の一部を別の文字列に置換する関数。
たとえば、文字列の「axxle」の「x」を「p」に置換し、「apple」とすることができます。

文字列を置換する関数
REPLACE（置換対象の文字列, 置換前の部分文字列, 置換後の部分文字列）
=> 置換処理された後の文字列


SUBSTRING/SUBSTR -一部を抽出する
文字列の一部分だけを取り出したい場合には、SUBSTRING関数またはSUBSTR関数を利用する。

文字列の一部を抽出する関数
SUBSTRING（文字列を表す列, 抽出を開始する位置, 抽出する文字の数）
=> 抽出された部分文字列

SUBSTR（文字列を表す列, 抽出を開始する位置, 抽出する文字の数）
=> 抽出された部分文字列

※抽出する文字の数を省略し、文字列の最後まで抽出対象とする場合もある
※位置や数は文字数またはバイト数で指定する


CONCAT -文字列を連結する
文字列を連結するには、通常、||演算子や+演算子を使う
環境によってはCONCAT関数を利用することができる

文字列を連結する関数
CONCAT（文字列, 文字列[, 文字列…]）
=> 連結後の文字列


5.5
数値にまつわる関数

ROUND -指定桁で四捨五入
少数の取り扱いや金額計算などでよく見られる数値の丸め処理（四捨五入や切り上げ、切り捨て）も、関数で用意されている。
ROUND関数は、指定した位置で四捨五入した結果を返す関数。

指定桁で四捨五入する関数
ROUND（数値を表す列, 有効とする桁数）
=> 四捨五入した値

※「有効とする桁数」に指定する値が正の場合は少数部の桁数、負の場合は整数部の桁数を表す


TRUNC -指定桁で切り捨てる
四捨五入ではなく切り捨てをしたい場合には、TRUNC関数を使う。

指定桁で切り捨てる関数
TRUNC（数値を表す列, 有効とする桁数）
=> 切り捨てた値

※「有効とする桁数」に指定する値が正の場合は少数部の桁数、負の場合は整数部の桁数を表す


POWER -べき乗を計算する
ある値のべき乗（2乗や3乗など）を計算したい場合、*演算子でも実現可能ですが、
POWER関数を用いると便利


べき乗を計算する関数
POWER（数値を表す列, 何乗するかを指定する数値）
=> 数値を指定した回数だけ乗じた結果


5.6
日付にまつわる関数

現在の日時を得る
プログラムからデータベースを書き換える際、更新した日付や時刻を列に記録しておくことがよくある。
現在の日時はCURRENT_TIMESTAMP関数、現在の日時はCURRENT_DATE関数、現在の時刻はCURRENT_TIME関数で得ることができる

現在の日時を得る関数
CURRENT_TIMESTAMP => 現在の日時（年、月、日、時、分、秒）
CURRENT_DATE => 現在の日付（年、月、日）
CURRENT_TIME => 現在の時刻（時、分、秒）

※引数は指定不要なため、関数名の後に（）は付けない。


5.7
変換にまつわる関数

CAST -データ型を変換する
データベースを活用するようになると、ある型のデータを別の型として扱ったほうが便利に感じる場合がある
そのような場面で活躍するのがCAST関数

データ型を変換する関数
CAST（変換する値 AS 変換する型） => 変換後の値


COALESCE -最初に登場するNULLでない値を返す

COALESCE関数は「複数の引数を受け取り、受け取った引数を左から順番にチェックし、
その中から最初に見つかったNULLでない引数を返す」という動作をする関数

最初に登場するNULLでない値を返す関数
COALESCE（列や式1, 列や式2, 列や式3…）
=> 引数のうち、最初に現れたNULLでない引数

※任意の数の引数を指定できる。ただし、すべての引数の型を一致させる必要がある。
※もしすべての引数がNULLの場合、戻り値はNULLになる。


5.8
この章のまとめ

計算式
・列やリテラルを使った式で、結果が真または偽にならないものを計算式という。
・計算式を評価すると計算結果に化ける。
・計算式は、SELECT文の選択列リスト、INSERT文やUPDATE文のテーブルに格納する値、
  その他の修復句など、さまざまな場所で使用できる。

計算式に用いる演算子
・四則演算を行う演算子を算術演算子という。
・||演算子や+演算子で文字列の連結ができる。
・CASE演算子は、列の値や条件式を評価して、任意の値に変換する。

関数
・関数は、引数に対して決められた処理を行い、戻り値に変換する。
・関数は、処理の内容や戻り値に応じて、文字列関数、算術関数、日付関数、変換関数などに分類される。
・関数は、DBMS製品による違いが大きい機能であるため、各製品のマニュアルなどで処理の内容の確認が必要不可欠である


5.9
練習問題

5-1
1.
（A）
UPDATE 試験結果
  SET 午後1 = (80*4) - (86+68+91)
  WHERE 受験者ID = 'SW1046'

（B）
UPDATE 試験結果
  SET 論述 = (68*4) - (65+53+70)
  WHERE 受験者ID = 'SW1350'

（C）
UPDATE 試験結果
  SET 午後 = (56*4) - (59+56+36)
  WHERE 受験者ID = 'SW1877'

2.
SELECT 受験者ID AS 合格者ID
  FROM 試験結果
  WHERE 午前 >= 60
  AND 午後1 + 午後2 >= 120
  AND 0.3 * (午前 + 午後1 + 午後2 + 論述) <= 論述


5-2
あるアンケートの回答者に関する情報を登録した回答者テーブルがある。
このテーブルでは、メールアドレスの列は30桁のCHAR型、国名の列は20桁のVARCHAR型、
住居の列は1桁のCHAR型、年齢の列はINTEGER型で定義されている。

1.メールアドレスのさいごの2文字が国コードであることを利用して、国名を登録したい。
国コードを日本語の国名に変換のうえ、国名列を更新する。ただし、1つのSQL文で全行を更新すること。

UPDATE 回答者
SET 国名 = CASE SUBSTRING(TRIM(メールアドレス),
                LENGTH(TRIM(メールアドレス))-1, 2)
          WHEN 'jp' THEN '日本'
          WHEN 'uk' THEN 'イギリス'
          WHEN 'cn' THEN '中国'

2.メールアドレスと住居、年齢を一覧表示する。ただし、次の条件をみたした形で表示すること
（1）メールアドレスの余分な空白は除去する
（2）住居と年齢は1つの項目とし、年齢は年代として表示する。
（3）項目の見出しはそれぞれ「メールアドレス」「属性」とする
    なお、住居はDが戸建て、Cが集合住宅を表している。

SELECT TRIM(メールアドレス) AS メールアドレス,
CASE WHEN 年齢 >= 20 AND 年齢 < 30 THEN '20代'
     WHEN 年齢 >= 30 AND 年齢 < 40 THEN '30代'
     WHEN 年齢 >= 40 AND 年齢 < 50 THEN '40代'
     WHEN 年齢 >= 50 AND 年齢 < 60 THEN '50代'
END
|| ':' ||
CASE 住居 WHEN 'D' THEN '戸建て'
         WHEN 'C' THEN '集合住宅' END AS 属性
FROM 回答者

5-3
1.依頼された文字は、何文字の刺繍が必要かを求める。「文字」列のデータをもとに、1つのSQL文で「文字数」列の全行を更新する。
  ただし、「文字」列には半角の空白が入る可能性があるが、空白は文字数に含めない。
UPDATE 受注
  SET 文字数 = LENGTH(REPLACE(文字, ' ', ''))

2.受注内容を一覧表示する。一覧には、受注日、受注ID、文字数、書体名、単価、特別加工料を受注日および受注ID順に表示したい。
  ただし、特別加工料がかからないものについては、特別加工料をゼロとする。
SELECT 受注日, 注文ID, 文字数,
  CASE COALESECE(書体コード, '1')
    WHEN '1' THEN 'ブロック体'
    WHEN '2' THEN '筆記体'
    WHEN '3' THEN '草書体' END AS 書体名,
  CASE COALESECE(書体コード, '1')
    WHEN '1' THEN 100
    WHEN '2' THEN 150
    WHEN '3' THEN 200 END AS 単価,
  CASE WHEN 文字数 > 10 THEN 500
    ELSE 0 END AS 特別加工料
FROM 受注 ORDER BY 受注日, 受注ID

3.受注IDが113の注文に対して、文字の一部を変更したいという依頼があった。
  登録されている文字を次の依頼内容に合わせて更新する。
  依頼内容:半角スペースを「★」に変更
UPDATE 受注
  SET 文字 = REPLACE(文字, ' ', '★')
WHERE 受注ID = '113'


第6章
集計とグループ化

データを集計する
集計関数とは
「SUM」は、検索結果のデータを集計する集計関数の1つ。
ほかにも、最大値や平均値などを算出する集計関数も存在する。
集計関数を使うと、SELECT文による検索結果は該当する各行ではなく、該当する行が集計された形で出力されるようになる。


集計関数の特徴
SUMのような集計関数は、一見するとすでに学習したLENGTHやCOALESCEといった関数とよく似ている。
しかし、その動作や結果表の形がまったく異なる点に注意が必要。

第5章で紹介した関数は、検索結果の各行に対して、同じ処理や計算をそれぞれ行うように命令するもの。
これらの関数を使っても、検索結果の行が増えたり減ったりすることはない。

一方、この章で学習する集計関数は、集計の対象となったすべての行に対して1回だけ計算を行い、1つの答えを出す。
必然的に結果表は必ず1行になる。

集計関数の特徴
・検索対象の全行をひとまとめに扱い、1回だけ集計処理を行う。
・集計関数の結果は、必ず1行になる。

6.2
集計関数の使い方
代表的な集計関数

SUM 各行の値の合計を求める
MAX 各行の値の最大値を求める
MIN 各行の値の最小値を求める
AVG 各行の値の平均値を求める
COUNT 行数をカウントする


合計、最大、最小、平均を求める
検索結果のある列に対して、合計、最大値、最小値、平均値を求めたい場合、
それぞれSUM,MAX,MIN,AVG関数を利用する。

合計、最大値、最小値、平均値を求める集計関数
SUM（列） => 合計
MAX（列） => 最大値
MIN（列） => 最小値
AVG（列） => 平均値

SELECT 
    SUM(出金額) AS 合計出金額,
    AVG(出金額) AS 平均出金額,
    MAX(出金額) AS 最も大きな散財,
    MIN(出金額) AS 最も小さい支払い
FROM 家計簿

検索結果の行数を求める
COUNT関数は、検索結果の行数を数えてくれる集計関数。
この関数には、2つの記述方法がある。

行数を数える集計関数
COUNT(*) => 検索結果の行数
COUNT(列) => 検索結果の指定列に関する行数

COUNT(*)とCOUNT(列)の違い
・COUNT(*)は、単純に行数をカウントする（NULLの行も含める）。
・COUNT(列)は、指定列がNULLである行を無視してカウントする

重複した値を除いた集計
AVG,SUM,COUNTの各関数では、「DISTINCT」を指定することによって、
その列で重複している値を除いた状態で集計が行われる。

SELECT COUNT(DISTINCT 費目) FROM 家計簿


6.3
集計に関する4つの注意点
SELECT文でしか利用できない
集計関数は、これまで紹介してきたような「SELECT文の選択列りすと部分」やORDER BY句、6.4節で紹介するHAVING句の中で利用する。
WHERE句の中では利用できない。

検索結果に対して集計を行うための道具である集計関数は、UPDATE文、INSERT文、DELETE文で利用することはできない。

集計関数が記述できる場所
集計関数は、SELECT文の選択列リストかORDER BY句、HAVING句だけに記述できる。


結果表がデコボコになってはならない
結果表は、常に列ごとの行数が一致するn行m列の長方形型でなければならないもの。
もし結果表がデコボコ型になるようなSQL文を実行すると、エラーになる。


SQLの結果表
・結果表は必ず長方形型になる。
・結果表がデコボコになるようなSQL文は実行できない。


引数に許される型が異なる

NULLの取り扱い
集計関数の場合はそれぞれの取り扱いが異なる。
p186 6-3表

6.4
データをグループに分ける
グループ別の集計

検索結果をひとまとまりとして集計し、1つの結果を得ることができる。
「SELECT SUM（出金額） AS 出金額の合計 FROM 家計簿」というSQL文を使えば、次のような結果が簡単に得られました。

「費目別の出金額集計表」を得るにはどうすればよいか

グループ化
SQLには、集計に先立って、指定した基準で検索結果をいくつかのまとまりに分けるグループ化と呼ばれる機能が備わっている。
集計はグループごとに行われ、グループごとの集計結果が結果表の形で得らる。


グループ化して集計する基本構文
SELECT グループ化の基準列名…, 集計関数
  FROM テーブル名
  （WHERE 絞り込み条件）
  GROUP BY グループ化の基準列名…


グループ集計の流れ
グループ集計は、3つのステップで実行される。まず第1ステップとして、
もとの表に対してWHERE句による通常の検索処理が行われ、行が絞り込まれる

次に、検索結果はGROUP BY句で指定された列に同じ値を持つ行ごとに分類される

最後に、各グループに対して集計関数の処理が行われた後、
SELECT句の選択列リストによって列が絞り込まれ、結果表となる。


グループ化した集計関数
・グループ化するには、GROUP BY句に基準となる列を指定する。
・集計関数は、データの値をグループごとにまとめて計算する。
・集計関数の結果の行数は、必ずグループの数と一致する。

グループ集計後の絞り込み

集計関数はWHERE句に記述できない
行を絞り込む段階では、まだ集計がおわっていないため、集計関数は
WHERE句では利用できない。

集計処理を行ったあとの結果表に対して絞り込みを行いたい場合は、WHERE句ではなく
HAVING句を用いる。

集計結果に対して絞り込む基本情報
SELECT グループ化の基準列名…, 集計関数
  FROM テーブル名
  （WHERE もとの表に対する絞り込み条件）
  GROUP BY グループ化の基準列名…
  HAVING 集計結果に対する絞りこみ条件

HAVING句に記述する条件式は、WHERE句に記述するものと非常によく似ている。
WHERE句と同じように、ANDやORの論理演算子で複数の条件式を組み合わせることもできる。
異なるのは、絞り込みが実行されるタイミング。

HAVING句は、集計結果がすべて揃った最後の段階で実行される。
そのため、WHERE句とは異なり、集計関数を記述することが可能になる。

SELECT 費目, SUM(出金額) AS 費目別の出金合計
  FROM 家計簿
  [WHERE 条件式]
  [GROUP BY グループ化列名]
  [HAVING 集計結果に対する条件式]
  [GROUP BY 並び替え列名]

  カッコでかこんな修飾は必要に応じて任意で記述するものですが、それぞれの修飾を記述できる場所は定められている。
  特にORDER BY句は、ほかにどのような修飾を書いたとしても、必ず最後に記述しなければなりません。


グループ集計と選択列リスト
グループ集計を行うSELECT文の選択列リストに指定する列は、次のどちらかに当てはまるものでなければならない

1.GROUP BY句にグループ化の基準列として指定されいる
2.集計関数による集計の対象となっている

これらに当てはまらない列を抽出しようとすると「デコボコな結果表」になってしまう。


6.5
集計テーブルの活用

集計テーブルの活用
・あるテーブルの集計結果を格納するための別テーブル（集計テーブル）を作成する
・集計関数を用いて集計処理を1回行い、結果を集計テーブルに登録しておく
・集計結果が必要な場合は、すでに作った集計テーブルに格納されている計算済みの集計結果を利用する

集計テーブルを更新する
集計テーブルを用いるリスク
集計テーブルに格納されている内容は、最新のデータを用いた集計より古くなってしまう可能性がある。

集計テーブルに不可欠な更新作業
集計テーブルの内容が古くならないように、定期的に再集計して内容を更新する作業が不可欠である。


6.6
この章で学習した内容
集計
・集計関数を用いてデータを集計することができる。
・集計関数は、まとめたグループごとに1つの結果を算出する。
・集計関数はSELECT文でのみ使用できる。

グループ化
・GROUP BY句にグループ分けの基準となる列を指定することで、グループ別に集計を行うことができる。
・GROUP BY句を用いない集計では、検索結果の全件を1つのグループとして扱う。
・集計値をもとにして特定のグループのみを抽出するには、HAVING句を用いる。

主な集計関数
SUM データを合計する 数値
MAX 最も大きい値を求める 数値、日付と時刻、文字列
MIN 最も小さい値を求める 数値、日付と時刻、文字列
AVG データを平均する 数値
COUNT 行数をカウントする すべてのデータ型

6.7
練習問題
6-1
1.日本全体としての年間降水量の合計と、年間の最高気温・最低気温の平均
SELECT SUM(降水量), AVG(最高気温), AVG(最低気温)
FROM 都市別気象観測

2.都市名「東京」の年間降水量と、各月の最高気温、最低気温の平均
SELECT SUM(降水量), AVG(最高気温), AVG(最低気温)
FROM 都市別気象観測
WHERE 都市名 = '東京'

3.各都市の降水量の平均と、最も低かった最高気温、最も高かった最低気温
SELECT 都市名, AVG(降水量), MIN(最高気温), MAX(最低気温)
FROM 都市別気象観測
GROUP BY 都市名

4.月別の降水量、最高気温、最低気温の平均
SELECT 月, AVG(降水量), AVG(最高気温), AVG(最低気温)
FROM 都市別気象観測
GROUP BY 月

5.1年間で最も高い最高気温が38度以上を記録した月のある都市名とその気温
SELECT 都市名, MAX(最高気温)
FROM 都市別気象観測
GROUP BY 都市名
HAVING MAX(最高気温) >= 38

6.1年間で最も低い最低気温が-10度以下を記録した月のある都市名とその気温
SELECT 都市名, MIN(最低気温)
FROM 都市別気象観測
GROUP BY 都市名
HAVING MIN(最低気温) <= -10


6-2
1.現在入室中の社員数を取得する
SELECT COUNT(*) AS 社員数
FROM 入退室管理
WHERE 退室 IS NULL

2.社員ごとの入室回数を、回数の多い順に取得する
SELECT 社員名, COUNT(*) AS 入室回数
FROM 入退室管理
GROUP BY 社員名
ORDER BY 2 DESC

3.事由区分ごとの入室回数を取得する（事由区分はわかりやすく表示する）
SELECT CASE 事由区分 WHEN '1' THEN 'メンテナンス'
                    WHEN '2' THEN 'リリース作業'
                    WHEN '3' THEN '障害対応'
                    WHEN '4' THEN 'その他'
       END AS 事由,
       COUNT(*) AS 入室回数
FROM 入退室管理
GROUP BY 事由区分

4.入室回数が10回を超過する社員について、社員名と入室回数を取得する
SELECT 社員名, COUNT(*) AS 入室回数
FROM 入退室管理
GROUP BY 社員名
HAVING COUNT(*) > 10

5.これまでに障害対応が発生した日付と、それに対応した社員数を取得する
SELECT 日付, COUNT(社員名) AS 対応社員数
FROM 入退室管理
WHERE 事由区分 = '3'
GROUP BY 日付

6-3
2と5




第7章
副問い合わせ

7.1
検索結果に基づいて表を操作する

2回のSELECTが必要な状況
ひとまずSELECTやUPDATEなどを実行するような機会は、実はデータベースを利用するうえでよくある。

SELECTをネストする
ひとまずSERECT文で何らかの検索結果を得て、得られた具体的な値を用いてさらにSELECTやUPDATEなどを実行したい場合、
それを1つのSQL文で記述することができる。

最も大きな出費の費目と金額を求める
SELECT 費目, 出金額 FROM 家計簿
  WHERE 出金額 = (SELECT MAX(出金額) FROM 家計簿)

一般的に、あるものがその内側に別のものを内包している状態をネスト構造や入れ子と呼ぶ。
ほかのSQL文の一部として登場するSELECT文のことを、副問い合わせや副紹介、またはサブクエリと呼ぶ。

副問い合わせとは
ほかのSQL文の一部として登場するSELECT文。丸カッコでくくって記述する。

内部に複数の副問い合わせを持つことや、副問い合わせの中にさらに別の副問い合わせを記述することも可能


副問い合わせを習得するコツ
個々のSQL文を1つずつ作り、あとから組み立てあげればよい。

副問い合わせを習得するコツ
・副問い合わせが処理される仕組みを理解しておく。
・副問い合わせの代表的な3つのパターンを学んでおく。


コツ1 : 副問い合わせが処理されるしくみ
副問い合わせを含むSQL文では、まず副問い合わせのSELECT文が実行され、その結果である具体的な値に「化ける」ことになる。
その後、化けた値を当てはめて組み立られた外側のSQL文が実行される。

副問い合わせの動作
まず、内側にあるSELECT文が実行され結果に化ける。
そして、外側のSQL文が実行される。

コツ2 : 副問い合わせのパターン
副問い合わせの3つのパターン
・単一の値の代わりとして、副問い合わせの検索結果を用いる。
・複数の値の代わりとして、副問い合わせの検索結果を用いる。
・表の値の代わりとして、副問い合わせの検索結果を用いる。



7.2
単一の値の代わりに副問い合わせを用いる

単一行副問い合わせ
単一行副問い合わせとは、副問い合わせの検索結果が1行1列の値になるパターンを指す。
この副問い合わせの結果、1つの値に化けると考えることもできる。
単一行副問い合わせは、単一の値を記述するような場所であれば、基本的にどこでも記述することができる。
代表的な場所としては、SELECT文の選択列リストやUPDATE文のSET句などがある。

単一行副問い合わせとは
・検索結果が1行1列の1つの値となる副問い合わせを指す。
・SELECT文の選択列リストやFROM句、UPDATE文のSET句、また1つの値との判定を行う
WHERE句の条件式などに記述することができる。

SET句で利用する
SET句の利用例

UPDATE 家計簿集計
  SET 平均 = (SELECT AVG(出金額)
             FROM 家計簿アーカイブ
             WHERE 出金額 > 0
             AND 費目 = '食費')
WHERE 費目 = '食費'

# 副問い合わせの結果は5000


選択列リストで利用する
SELECT文の選択列リストでの利用例
SELECT 日付, メモ, 出金額,
       (SELECT 合計 FROM 家計簿集計
       WHERE 費目 = '食費') AS 過去の合計額
FROM 家計簿アーカイブ
WHERE 費目 = '食費'

# 副問い合わせの結果は10380

7.3
複数の値の代わりに副問い合わせを用いる

複数行副問い合わせとは、副問い合わせの検索結果が複数の行から成る単一列（n行1列）の値になるパターンを指す。
複数行副問い合わせは、SQL文中で複数の値と列挙するような場所に、その代わりとして記述することができる。
具体的には、IN,ANY,ALL演算子を用いた条件式が代表的。

複数行副問い合わせとは
・検索結果がn行1列の複数の値となる副問い合わせ。
・複数の値との判定を行うWHERE句の条件式や、SELECT文のFROM句に記述することができる

IN演算子で利用する
SELECT * FROM 家計簿集計
WHERE 費目 IN ('食費', '水道光熱費', '教養娯楽費', '給料')

IN演算子の右には、文字列値が挙列されていますが、この部分を副問い合わせに置き換えることができる。

SELECT * FROM 家計簿集計
WHERE 費目 IN (SELECT DISTINCT 費目 FROM 家計簿)


ANY/ALL演算子で利用する
ANYやALLも、複数行副問い合わせと組み合わせて利用される代表的な演算子

家計簿テーブル内の費目が食費で、かつ出金額が家計簿アーカイブテーブル内の食費に関連する行の中で最も小さい値よりも小さい行
SELECT * FROM 家計簿
WHERE 費目 = '食費'
AND 出金額 < ANY (SELECT 出金額 FROM 家計簿アーカイブ
                 WHERE 費目 = '食費')

ANY演算子は、左辺の値と右辺に列挙された値とを比較して、いずれかの値と併記した比較演算子が成立するかを判定する。
上記の例では、<演算子をANYと組み合わせているので、
3~4行目は「副問い合わせの結果で得られる複数の値のいずれかより出金額が小さければ」という意味の条件式になる。

エラーとなる副問い合わせ
複数行副問い合わせの結果はn行1列、つまり「複数の値」
IN演算子やANY演算子の「カンマで区切った値の挙列」の代わりに記述できても、
単一の値の代わりに記述することはできない。

複数行と比較したいときには
複数行副問い合わせは複数の値に化けるので、単なる等号や不等号では比較できない。
等号や不等号にANY/ALL演算子を組み合わせたり、IN/NOT IN演算子を用いたりすることで、複数の値と比較できる。

副問い合わせとNULL
副問い合わせの結果がNULLを含んでいた場合
NOT INまたは<>ALLで判定する副問い合わせの結果にNULLが含まれると、全体の結果もNULLとなる

データにNULLが含まれてしまったために、取得できるはずのデータが取得できないというケースは、
データベースを使ったソフトウェアで陥りやすい落とし穴。
原因の特定が難しい場合も多いので、特に注意。

副問い合わせの結果から確実にNULLを除外する方法
1.副問い合わせの絞り込み条件に、IS NOT NULL条件を含める。
2.COALESECE関数を使ってNULLを別の値に置き換える。


7.4
表の代わりに副問い合わせを用いる

表の結果となる副問い合わせ
副問い合わせの検索結果が複数の行と複数の列から成る表形式（n行m列）の値となるパターン
従って、この副問い合わせを実行した結果は、表の形に化けるとも考えることができる。
このパターンの副問い合わせは、通常のSQL文において表を記述できる箇所、たとえばSELECT文のFROM句や
INSERT文などに記述することができる。

表形式の結果となる副問い合わせとは
・検索結果がn行m列の表となる副問い合わせ。
・SELECT文のFROM句やINSERT文などに記述する


FROM句で利用する
SELECT SUM(SUB.出金額) AS 出金額合計
  FROM (SELECT 日付, 費目, 出金額
        FROM 家計簿
        UNION
        SELECT 日付, 費目, 出金額
        FROM 家計簿アーカイブ
        WHERE 日付 >= '2022-01-01'
        AND 日付 <= '2022-01-31') AS SUB

外側のSQL文は、「SELECT ~FROM ~」の単純なSELECT文ですが、そのFROM句は1つの大きな副問い合わせで構成されている。
副問い合わせの部分は、家計簿テーブルと家計簿アーカイブの2022年1月分がUNIONで足し合わされているため、これを1つの
テーブルのように捉えることが可能。
また、副問い合わせの部分に「SUB」という別名が付けられている。その別名を利用して、外側のSELECTの選択列リストでは、
副問い合わせで得られる表の項目を明示している。


INSERT文で利用する
INSEET文は、原則として、1回の呼び出しで1行しか追加できない。
単純に考えると、100行分のデータを追加したい場合は、100回のINSERT文を実行する必要がある。

副問い合わせを使えば1回のINSERT文で複数行のデータを登録することが可能になる。

INSERT INTO 家計簿集計（費目, 合計, 平均, 回数）
SELECT 費目, SUM（出金額）, AVG（出金額）, 0
FROM 家計簿
WHERE 出金額 > 0
GROUP BY 費目

上記の例は2行目以降、最後までが副問い合わせ。
これまでと違い副問い合わせは、カッコでくくられていない。

7.5
この章のまとめ
SQL文のネスト
・SQL文の中に別のSELECT文を記述することができ、これを副問い合わせや副照会、またはサブクエリという
・副問い合わせは、実行とすると何らかの値に置き換わる。
・副問い合わせは、より内側にあるものから外側に向かって順に評価されていく。

副問い合わせのパターン
・副問い合わせの結果が1行1列になるものを単一行副問い合わせという。
・副問い合わせの結果がn行1列になるものを複数行副問い合わせという。
・副問い合わせの結果がn行m列になる副問い合わせも利用される。

複数行副問い合わせと演算子
・複数行副問い合わせは、IN,ANY,ALL演算子などと合わせてよく用いられる。
・複数行副問い合わせの結果にNULLが含まれると、NOT IN,<>ALL演算子の評価結果のもNULLとなる。

7.6
練習問題
7-1
（A）単一行副問い合わせ
（B）SELECT
（C）SET
（D）n
（E）1
（F）複数行副問い合わせ
（G）IN,IN NOT
（H）ANY,ALL
（I）FROM
（J）表
（K）INSERT

7-2
回答P237

7-3
1.飼育県別に飼育頭数をカウントし、その結果を次の頭数集計テーブルに登録する

INSERT INTO 頭数集計
SELECT 飼育県, COUNT(個体識別番号)
FROM 個体識別
GROUP BY 飼育県

2. 1.で作成した頭数集計テーブルで、飼育頭数の多いほうから3つの都道府県で飼育されている牛のデータを、
   個体識別テーブルより抽出する。抽出する項目は、都道府県名、個体識別番号、雌雄とする。
   ただし、雌雄はコードではなく「雄」「雌」の日本語表記とする。

SELECT 飼育県 AS 都道府県名, 個体識別番号,
CASE 雌雄コード WHEN '1' THEN '雄'
              WHEN '2' THEN '雌' END AS 雌雄
FROM 個体識別
WHERE 飼育県 IN (SELECT 飼育県 FROM 頭数集計
                ORDER BY 頭数 DESC
                OFFSET 0 ROWS FETCH NEXT 3 ROWS ONLY)

3.個体識別テーブルには母牛についてもデータ登録されており、母牛が乳用種である牛の一覧を個体識別テーブルより抽出したい。
  抽出する項目は、個体識別番号、品種、出生日、母牛番号とする。なお、品種は、コードではなく「乳用種」「肉用種」「交雑種」の日本語表記とする。
SELECT 個体識別番号,
CASE 品種コード WHEN '01' THEN '乳用種'
              WHEN '02' THEN '肉用種'
              WHEN '03' THEN '交雑種' END AS 品種, 出生日, 母牛番号
FROM 個体識別
WHERE 母牛番号 IN (SELECT 個体識別番号 FROM 個体識別
                  WHERE 品種コード = '01')


複数テーブルの結合
8.1
リレーショナルの意味

これまで学んだこと
第1部 基本的なデータの格納と取得
・4大命令でテーブルにデータを出し入れできる（第2章）
・WHERE句で処理対象行を絞り込める（第3章）
・ORDER BYやDISTINCTで検索結果に追加の処理を施させる（第4章）

第2部 データ取得時の計算処理
・式や関数を用いて、計算や集計ができる（第5、6章）
・検索結果に基づいてデータを操作できる（第7章）

データベースの優位性
データを安全、確実、高速に取り扱うために生まれたデータベースは、
表計算ソフトにはないさまざまな機能を備えている

外部キーとリレーションシップ
「家計簿テーブル」と「費目テーブル」のように、ある2つのテーブルの間に情報としての関連がある場合、
その関連をリレーションシップという。
また、家計簿テーブルの「費目ID」列のように、ほかのテーブルの関連行を指すための値を格納して
リレーションシップを結ぶ役割を担う列のことを外部キーという。

外部キー列の役割
外部キー列は、他のテーブルのある列（主キー列）の値を格納することで、
「その行が他のテーブルのどの行と関連しているか」を明らかにする。

複数テーブルに分けるメリット
コンピュータにとっては、このようにテーブルが分割されていたほうがデータを安全、確実、高速に取り扱いやすい。

複数のテーブルに分けるメリット
データを複数のテーブルに分けて格納した方が、安全、確実にデータを管理しやすい

デメリットの克服
データベースの多くは、管理に適した形態の複数テーブルから、人間が理解しやすい形態の1つの結果表を得るための
結合（join）という機能を備えている。

リレーショナルデータベース（RDB）の真の実力
RDBは、データを複数テーブルで安全、確実に管理しながら、
ひつように応じて「人間にわかりやすい表」に結合することができる。



8.2
テーブルの結合

結合の基本的な使い方

テーブルAとテーブルBの結合
SELECT 選択列リスト
FROM テーブルA
JOIN テーブルB
ON 両テーブルの結合条件

例
家計簿テーブルに費目テーブルの内容を結合する
SELECT 費目, 名前 AS 費目, メモ
FROM 家計簿
JOIN 費目
ON 家計簿.費目ID = 費目.ID

DBMSはまず2つのテーブルを結合した上で、列の絞り込み（選択列リストの指示による）や
行の絞り込み（WHERE句の指定による）を行っていく


結合の動作イメージ
また、結合に関係する2つのテーブルは対等な関係ではない。
あくまでもFROM句で指定したテーブル（以後、左表）が主役であり、
それにJOIN句で指定したテーブル（以後、右表）の内容を必要に応じてつないでいく

結合とは
結合とは、テーブルをまるごとつなぐのではなく、結合条件が満たされた行を1つひとつつなぐことである。


8.3
結合条件の取り扱い
結合相手が複数行の場合

右表の結合条件列が重複するときは…
つなぐべき右表の行が複数あるとき、DBMSは左表の行を複製して結合する。
結果表の行数は、もとの左表の行数より増える。

結合相手のない結合
右表に結合相手の行がない場合や、左表の結合条件の列がNULLの場合、結合結果から消滅する。


左外部結合
SELECT ~ FROM 左表の名前
LEFT JOIN 右表の名前
ON 結合条件


RIGHT JOINとFULL JOIN
左外部結合は「NULLの行を生み出してでも、左表の全行を必ず出力する」処理
同様に、右外部結合や完全外部結合も存在する。


その他の外部結合
・右外部結合: 右表の全行を必ず出力する
SELECT ~ FROM 左表の名前
RIGHT JOIN 右表の名前
ON 結合条件

・完全外部結合: 左右の表の全行を必ず出力する
SELECT ~ FROM 左表の名前
FULL JOIN 右表の名前
ON 結合条件

左外部結合、右外部結合、完全外部結合は、いずれも本来結果表から消滅してしまう行も強制的に出力する効果がある。
これらを総称して外部結合という。対して、結合すべき相手の行が見つからない場合に行が消滅してしまう通常の結合は、
内部結合という。


8.4
結合に関するさまざまな構文

テーブル名の指定
2つのテーブルを結合すると、1つのSQL文に、同じ名称の列が複数登場する場合がある。
どちらのテーブルの列を取り出せばよいかを判断できず、DBMSが困ることがある。
このような場合、ON句に指定した結合条件と同じように、列名指定の前にテーブル名と「.」（ドット）を加え、
どのテーブルに属する列であるかを明示的に指定することができる。

なお、テーブル名が長く複雑な場合、ASで別名をつけておくと列指定や結合条件の記述が簡潔になる


3テーブル以上の結合
「JOIN~ ON~」を繰り返して、3つ以上のテーブルを結合することもできる。
この場合も一度に3つのテーブルが結合されるわけではなく、前から順に1つずつ結合処理が行われていく。


副問い合わせの結果との結合
JOIN句のすぐ後ろに記述できるのは、テーブルだけではない。
「表形式のデータに化ける副問い合わせ」も記述することができる。
テーブルの代わりに副問い合わせの結果を利用することを除けば、通常の結合と違いない。
ただし、選択列リストや結合条件の指定のために、副問い合わせに別名を付ける必要がある。


同じテーブル同士を結合
結合は異なるテーブル間で行われることが一般的ですが、自分自身と結合させることも可能。
同一テーブル同士を結合することを自己結合や再起結合という。
なお、自己結合を行う場合、選択列リストや条件式を記述するために、同じテーブルに異なる別名を付ける。


8.5
この章のまとめ

リレーションシップ
・本格的にデータベースを活用するには、通常、データは複数のテーブルに分けて格納する
・ほかのテーブルの行と関連付けるために、外部キーを利用してリレーションシップを構成する。
・外部キーとは、関連する他のテーブルの列（主キー列など）の値を記述した列である。

結合
・結合を用いることで、複数のテーブルに格納された関連するデータを1つの結果表として取り出すことができる。
・結合を行う相手テーブルを指定するためにJOIN句を、結合条件を指定するためにON句を記述する。
・外部結合を用いると、結合相手がない行も結果表に出力することができる。

結合構文のバリエーション
・3テーブル以上の結合も、順に1つずつ処理される。
・副問い合わせの結果表と結合することもできる。
・自分自身のテーブルと結合することができる。


8.6
練習問題
1.
A1 A2 B1 B2
 1  3  1  2

2.
A1 A2 B1 B2
 2  4  1  2

3.
A1 A2 B1 B2
 2  4  1  2
NULL NULL 3 NULL

4.
A.A1 C.A2 B1 B2
   1    3  1  2 


2.
社員情報を管理するデータベースに、3つのテーブルがある。これらを結合する。
1.部署名が入った全社員の一覧表
SELECT 社員番号, S.名前 AS 名前, B.名前 AS 部署名
FROM 社員 AS S
JOIN 部署 AS B
ON S.部署ID = B.部署ID


2.上司の名前が入った全社員の一覧表
SELECT S1.社員番号, S1.名前 AS 名前, S2.名前 AS 上司名
FROM 社員 AS S1
LEFT JOIN 社員 AS S2
ON S1.上司ID = S2.社員番号


3.部署名と勤務地が入った社員一覧表
SELECT 社員番号, S.名前 AS 名前, B.名前 AS 部署名, K.名前 AS 勤務地
FROM 社員 AS S
JOIN 部署 AS B
ON S.部署ID = B.部署ID
JOIN 支店 AS K
ON S.勤務地ID = K.支店ID


4.支店ごとの支店長名と社員数の一覧表
SELECT 支店ID AS 支店コード, K.名前 AS 支店名, S.名前 AS 支店長名, T.社員数
FROM 支店 AS K
JOIN 社員 AS S
ON K.支店長ID = S.社員番号
JOIN (SELECT COUNT(*) AS 社員数, 勤務地ID
      FROM 社員 GROUP BY 勤務地ID) AS T
ON K.支店ID = T.勤務地ID

5.上司と違う勤務地（離れて勤務している）社員の一覧表
SELECT S1.社員番号 AS 社員番号, S1.名前 AS 名前, K1.名前 AS 本人勤務地, K2.名前 AS 上司勤務地
FROM 社員 AS S1
JOIN 社員 AS S2
ON S1.上司ID = S2.社員番号
AND S1.勤務地ID <> S2. 勤務地ID
JOIN 支店 AS K1
ON S1.勤務地ID = K1.支店ID
JOIN 支店 AS K2
ON S2.勤務地ID = K2.支店ID


第３部
データベースの知識を深めよう

第9章
トランザクション
9.1
正確なデータ操作
正確なデータ操作を脅かすもの


トランザクション
私たちがDBMSに対して複数のSQL文を送る際、1つ以上のSQL文をひとかたまりとして扱うよう指示することができる。
このかたまりのことをトランザクションという。

DBMSによるトランザクションの制御
・トランザクションの途中で、処理が中断されないようにする
・トランザクションの途中に、他の人の処理が割り込めないようにする

DBMSがこのようにひとかたまりのSQL文を扱うことをトランザクション制御という

9.2
コミットとロールバック

トランザクションの中断
DBMSはどんな非常事であっても、トランザクションを「一部だけが実行されることはあってはならない、
途中で分割不可能なもの」として取り扱うから。


DBMSによるトランザクション制御（1）
DBMSは、トランザクションに含まれるすべてのSQL文について、必ず「すべての実行が完了している」か
「1つも実行されていない」かのどちらかの状態になるように制御する。

トランザクションに含まれる複数のSQL文が、DBMSによって不十分なものとして扱われる性質のことをトランザクションの
原子性という。


原子性確保のしくみ
トランザクション中のSQL文によってテーブルのデータが書き換えられると、そのデータは仮のものとして管理される。
そして、トランザクションが終了して初めて、それら「仮の書き換え」のすべてを確定させる。
この確定行為のことをコミットという。
もし、トランザクション中に異常が発生して中断した場合、DBMSはそれまで行ったすべての仮の書き換えをキャンセルして、
「なかったこと」にする。
このDBMSによる「なかったこと」にする動作をロールバックといい、SQL文のエラーで失敗したり、
明示的にキャンセルが指示された場合などに行われる。
もちろん、電源が落ちて突然処理が中断した場合も、再びデータベースを起動した際に自動的にロールバックが行われる。


トランザクションの指定方法
トランザクションを使うための指示
・BEGIN
  開始の指示。この指示以降のSQL文を1つのトランザクションとする。

・COMMIT
  終了の指示。この指示までを1つのトランザクションとし、変更を確定する。

・ROLLBACK
  終了の指示。この指示までを1つのトランザクションとし、変更の取り消しをする。


自動コミットモードの解除
多くのツールはデフォルト状態では自動コミットモードと呼ばれるモードで動作するため、
このモードにあるとき、DBMSは1つのSQLが実行されるたびに、自動的に裏でコミットを実行している。

9.3
トランザクションの分離
同時実行の副作用
世の中で利用されている情報システムにおいては、多くの利用者から1つのDBMSに対してたくさんのSQL文が送られる。

3つの代表的な副作用

副作用１ ダーティーリード
まだコミットされていない未確定の変更を、ほかの人が読めてしまう副作用をダーティーリードという。

副作用2 反復不能読み取り
反復不能読み取りとは、あるテーブルに対してSELECT文を実行した後、ほかの人がUPDATE文でデータを書き換えると、
次にSELECTした際に検索結果が異なってしまうという副作用。

副作用3 ファントムリード
ファントムリードは、反復不能読み取りと似ている。
2回のSELECT文の間に、ほかの人がINSERT文で行を追加すると最初と次のSELECTで取得する結果の行数が変わってしまうという副作用。


トランザクションの分離
DBMSは個々のトランザクションについて分離性を維持するために次のような制御を行う。

DBMSによるトランザクション制御（2）
DBMSは、あるトランザクションを実行する際、ほかのトランザクションから影響を受けないよう、
それぞれを分離して実行する。仮にほかのトランザクションと同時に実行していたとしても、
あたかも単独で実行しているのと同じ結果となるよう制御する。

DBMSはこの制御を行うために、内部でロックと呼ばれるしくみを使う。
あるトランザクションが現在読み書きしている行に鍵をかけ、ほかの人のトランザクションからは読み書きできないようにしてしまう。
トランザクションが特定の行などをロックすることを「ロックを取る」「ロックを取得する」と表現する

自分のトランザクションがコミットまたはロールバックで終了すると、かけた鍵は解除され、
ほかの人のトランザクションがその行を読み書きできるようになる。

自分が読み書きしたい行を他人がロックしている間、その相手のトランザクションが完了するまで自分は待たされる。
ロックの待ち時間は通常数ミリ秒以下と大変短いが、ロックがたくさん発生すると、データベースの動作は非常に遅くなってしまう。


分離レベル
多くのDBMSでは、どの程度厳密にトランザクションを分離するかをトランザクション分離レベルとして指定することができる。
デフォルトでREAD COMMITTEDという分離レベルで動作する。
これは、さほど厳しいロックをかけないためダーティリードしか防ぐことはできませんが、ある程度高速に動作するという特徴を持っている。
ほかの分離レベルを利用したい場合、多くのDBMSではSET TRANSACTION ISOLATION LEVEL 命令を使用して任意の分離レベルを選択できる。

トランザクション分離レベルの指定
SET TRANSACTION ISOLATION LEVEL 分離レベル名
SET CURRENT ISOLATION 分離レベル名


9.4
ロックの活用

明示的なロック
DBMSはトランザクションの分離性を確保するために自動的に行にロックをかける。
私たち自身が具体的に「いつ」「どの行に対して」ロックをする、という指示をする必要はない。

SQL文を使って指定した対象を明示的にロックすることもできる。
また、行以外にもテーブル全体やデータベース全体のロックも可能。

明示的なロックの種類
行ロック: ある特定の行だけをロックする
表ロック: ある特定のテーブル全体をロックする
データベースロック: データベース全体をロックする

ロックをかける際には、その制限の強さを指定することができる。排他ロックは、ほかからのロックを一切許可しないため
主にデータの更新時に利用される。共有ロックは、ほかからの共有ロックを許す特性があるため、データの読み取り時に多く利用される。

1.行ロックの取得 -SELECT ~ FOR UPDATE
通常、SELECT文で選択した行には自動的に共有ロックがかかる。
SELECT文の末尾に「FOR UPDATE」を追加すると、排他ロックがかかり、ほかのトランザクションからは該当行のデータを書き換えることができない。


明示的な行ロックの取得
SELECT ~ FOR UPDATE (NOWAIT)


2.表ロックの取得 -LOCK TABLE
ある特定の表全体をロックするには、LOCK TABLE命令を利用する

明示的な表ロックの取得
LOCK TABLE テーブル名 IN モード名 MODE (NOWAIT)


ロックは最小限に
・明示的にロックするときは、必要最小限の範囲に留める。
・排他ロックの代わりに共有ロックを使用できないかを検討する


デッドロック
データベースで同時にたくさんのトランザクションが実行されると、まれにデッドロックと呼ばれる状態に陥り、
トランザクションの処理が途中で永久的に止まってしまうことがある。

デッドロックの発生
「X」をロックしたトランザクションAが、次に「Y」もロックしようとしている一方で、
「Y」をロックした別のトランザクションBが、次に「X」をロックしようとするとき、デッドロックが発生する。

デッドロックが発生して処理が完全に停止してしまうことを防ぐため、多くのDBMSにはデッドロックを自動的に解決するしくみが備わっている。
DBMSは、実行中のトランザクションの中にデッドロックに陥っているものがないかを定期的にしらべ、もしそのようなものを発見したら
片方のトランザクションを強制的に失敗させることによって、デッドロック状態から抜け出せるようにする。


デッドロックを予防する方法
対策１ トランザクションの時間を短くする
対策２ 同じ順番でロックするようにする

同じ順番でロックする
SQL文を組み立てる際には、可能な限り同じ順番で行やテーブルにロックがかかるように意識する。


9.5
この章のまとめ

トランザクション
・複数のSQL文を不可分な1つの命令として扱うことができる
・DBMSは、トランザクションの原子性や分離性を保つよう制御を行う。

原子性
・トランザクションに含まれる複数のSQL文は、すべて実行されたか、1つも実行されていないかの状態になることが、DBMSにより保証される。
・コミットでトランザクション中のすべての処理が確定する
・ロールバックでトランザクション中のすべての処理がキャンセルされる
・DBMSに付属する多くのSQLクライアントは、デフォルトで自動コミットモードになっている

分離性
・トランザクションは、同時実行中のほかのトランザクションから影響を受けないよう、分離して実行される
・代表的な副作用には「ダーティリード」「反復不能読み取り」「ファントムリード」がある
・トランザクション分離レベルで、性能と分離のバランスを選ぶことができる

ロック
・行や表、データベース全体に、明示的にロックをかけることができる
・複数の対象に異なる順番でロックをかけようとする複数のトランザクションは、
デッドロックに陥ることがあるため注意が必要


9.6
練習問題

9-1
（A）トランザクション
（B）コミット
（C）原理性
（D）分離性
（E）トランザクション分離レベル

9-2
1.
・受注テーブルに行を追加した直後に処理が中断すると、在庫が減らないままになってしまう
・受注テーブルに行を追加した直後に処理が中断しても、出荷管理プログラムによって商品が出荷されてしまう

2.
BEGIN;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
INSERT INTO 受注 （注文番号, 日付, 顧客番号, 商品番号, 注文数）
VALUES ('1192296', '2022-04-08', '8828', '0008', 12);
UPDATE 在庫
SET 残数 = 残数 - 12
WHERE 商品番号 = '0008';
COMMIT;

9-3
ア.○
イ.×
ウ.×
エ.○
オ.×
カ.○
キ.×
ク.○
ケ.×



第10章
テーブルの作成

10.1
SQL命令の種類
データベースを使う2つの立場

データベースを利用する2つの立場
立場① データベースにデータの出し入れを指示する場所
立場② 立場①の人が、効率よく、安全にデータの出し入れができるような必要なテーブルの
      準備や各種設定を指示する立場


4種類の命令
DCLとは
DCLは、誰に、どのようなデータ操作やテーブル操作を許すかといった権限を設定するためのSQL命令の総称。
権限を付与するGRANT文と権限を剥奪するREVOKE文がある。

GRANT文とREVOKE文
GRANT 権限名 TO ユーザー名
REVOKE 権限名 FROM ユーザー名

これらは特にデータベースの全体を管理する、データベース管理者だけが使う命令。


10.2
テーブルの作成

テーブル作成の基本
テーブルを作成するには、代表的なDDLであるCREATE TABLE文を使う。
この文には、作成したいテーブルの名前、テーブルを構成する列と型の一覧を指定する。

テーブルの作成（基本形）
CREATE TABLE テーブル名（
列名1 列1の型名,
列名2 列2の型名,
:
列名X 列Xの型名
）


家計簿テーブルを作成する
CREATE TABLE 家計簿 (
  日付 DATE,
  費目ID INTEGER,
  メモ VARCHAR(100),
  入金額 INTEGER,
  出金額 INTEGER
)

デフォルト値の指定
テーブルを作成する際に、デフォルト値を決めておくことで、「特に指定しなければ入金額には0が格納される」というような設定が可能
そのためには、CREATE TABLE文にDEFAULTキーワードを指定する。

デフォルト値の指定を含むテーブルの作成
CREATE TABLE テーブル名(
  列名 型名 DEFAULT デフォルト値,
  :
)


データベース内に、同じ名前のテーブルを複数作ることはできない。
家計簿テーブルを作り直すために、家計簿テーブルを一旦削除しなければならない。
テーブルそのものを削除するにはDDLに属するDROP TABLE文を利用する。

テーブルの削除
DROP TABLE テーブル名


ALTER TABLE文
テーブル定義の内容を変更するには、ALTER TABLE文を使う。
この文では、具体的にテーブルの「何を」「どう」変えるかを指定する。

テーブル定義の変更
・列の追加
ALTER TABLE テーブル名 ADD 列名 型

・列の削除
ALTER TABLE テーブル名 DROP 列名



10.3
制約
人為的ミスに備える

あえて制限することで安全性を高める
予期しない値を格納できないように制限をかけることで、人為的ミスによるデータ破壊の可能性を減らすことができる。

加えて、多くのDBMSは制約というしくみを備えており、型よりもさらに強力な制限をかけることができる。
制約を使えば、「日付の列は絶対にNULLになってはならない」「入金額や出金額の列は0以上の数値しか格納してはならない」
などのきめ細かい制限をかけることができる。


基本的な3つの制約
制約は、CREATE TABLE文でデーブルを定義する際に、列定義の後ろに指定することが可能。

CREATE TABLE文中における制約の指定
CREATE TABLE テーブル名(
  列名 型 制約の指定,
  :
)

なお、1つの列に複数の制約を指定することもでる。
その場合はカンマではなく半角の空白で区切って、並べて記述する


①NOT NULL制約
NOT NULL制約が設定された列には、NULLの格納は許可されない。
なおNOT NULL制約はDEFAULT指定と組み合わせて利用されることがほとんど。
デフォルト値が設定されていれば、INSERT文で解くに値を入力しなくても自動的に値が設定されるため、エラーにならない

②UNIQUE制約
ある列の内容が決して重複してはならない場合、UNIQUE制約を付ける。
費目テーブルは家計簿で利用される費目の一覧が格納されるテーブル。
通常、同じ名前の費目が複数あってはならないため、列にUNIQUE制約が指定される。
なお、UNIQUE制約がかけられていても、NULLが格納された行が複数存在することは許される。
「NULLはNULLとも等しくない」から。

③CHECK制約
ある列に格納される値が妥当であるかを細かく判定したい場合は、CHECK制約を用いる。
「CHECK」の後ろのカッコないに記述した条件式が真となるような値だけが格納を許される。
たとえば、入金額と出金額に0以上の数値しか格納できないように制約をかけている。


主キー制約
主キーの列とは、「その列の値を指定すれば、どの1行のことかを完全に特定できる」という役割を与えられた列のこと。
主キーがその役割を果たすための条件には、「ほかの行と重複してはならない」
「必ず値が格納されなければならない（NULLであってはならない）」という2つが含まれていた。

主キーの役割を担う列には、主キー制約を付ける。
この制約が付いている列は、単なる「NULLも重複も許されない列」ではなく、そのテーブルで管理している
データを一意に識別する、主キーとしての役割が期待されているという意味を持つ。

主キー制約の指定（単独列）
CREATE TABLE 費目(
  ID INTEGER PRIMARY KEY,
  名前 VARCHAR(40) UNIQUE
)


主キー制約の指定（複合主キー）
CREATE TABLE 費目(
  ID INTEGER,
  名前 VARCHAR(40) UNIQUE,
  PRIMARY KEY(ID, 名前)
)

主キーの役割を担うべき列に関しては、万が一にもNULLや重複値が格納されると行を識別できないという
致命的な状況に陥るため、特別な理由がない限り、必ず主キー制約を指定するようにする。


10.4
外部キーと参照整合性
参照整合性の崩壊
外部キーが指し示す先にあるべき行が存在してリレーションシップが成立していることを参照整合性という。
異常な状態になってしまうことは「参照整合性の崩壊」といわれ、データベース利用において絶対に避けなければならない。


崩壊の原因
参照整合性の崩壊を引き起こすデータ操作
①「ほかの行から参照されている」行を削除してしまう。
②「ほかの行から参照されている」行の主キーを変更してしまう。
③「存在しない行を参照する」行を追加してしまう。
④「存在しない行を参照する」行に更新してしまう。


外部キー制約
参照整合性が崩れるようなデータ操作をしようとした場合にエラーを発生させ、強制的に処理を中断させる制約が外部キー制約
この制約は、参照元のテーブルの外部キー列に設定する。

外部キー制約の指定（1）
CREATE TABLE テーブル名 (
  列名 型 REFERENCES 参照先テーブル名(参照先列名)
  :
)


外部キー制約の指定（2）
CREATE TABLE テーブル名(
  :
  FOREIGN KEY(参照元列名)
  RECERENCES 参照先テーブル名(参照先列名)
)

10.5
この章で学習した内容
4種類のSQL命令
・データを格納したり取り出したりする場合は、DMLに属する命令を使う。
・データを格納するテーブル全体を作成したり削除したりする場合は、DDLに属する命令を使う。
・トランザクションの開始や終了を指示する場合は、TCLに属する命令を使う。
・DMLやDDLに関する許可や禁止を設定する場合は、DCLに属する命令を使う。

テーブルの作成と削除
・CREATE TABLE文を用いて、新規のテーブルを作成できる。
・テーブル作成時に、列にデフォルト値を指定できる。
・DROP TABLE文でテーブルを削除できる。
・ALTER TABLE文でテーブルの定義を変更できる。

制約
・テーブル作成時に各列に制約を設定し、予期しない値が格納されないよに安全装置を設けることができる。
・NOT NULL制約は、NULLの格納を防ぐことができる。
・UNIQUE制約は、重複した値の格納を防ぐことができる。
・CHECK制約は、格納しようとする値が妥当かどうかをチェックできる。
・主キーとして取り扱いたい列には、主キー制約を設定する。
・データの更新や削除によって外部キーによる参照整合性が崩れることがないように、外部キー制約を設定する。

10.6
練習問題
10-1
次のSQL命令の中からDDLに属するものを選ぶ
イ、ウ、キ

10-2
CREATE TABLE 学部 (
  ID CHAR(1), --学部を一意に特定する文字
  名前 VARCHAR(20), --学部の名前（必須、重複不可）
  備考 VARCHAR(100) --特にない場合は、’特になし’を設定
)
上記のテーブルの趣旨と目的を考慮し、適切なデフォルト値や制約を加えるようなSQL文を改善する

CREATE TABLE 学部 (
  ID CHAR(1) PRIMARY KEY,
  名前 VARCHAR(20) UNIQUE NOT NULL,
  備考 VARCHAR(100) DEFAULT '特になし' NOT NULL
)

10-3
CREATE TABLE 学生 (
  学籍番号 CHAR(8) PRIMARY KEY,
  名前 VARCHAR(30) NOT NULL,
  生年月日 DATE NOT NULL,
  血液型 CHAR(2) CHECK (
    血液型 IN ('A', 'B', 'O', 'AB') OR
    血液型 IS NULL
  ),
  学部ID CHAR(1) REFERENCES 学部（ID）
)

10-4
・学生テーブルで利用している学部について、学部テーブルから削除する。
・学生テーブルで利用している学部について、学部テーブルでID列を更新する。

10-5
理学部（IDは'R'）を廃止する。現在理学部に所属するすべての学生は、工学部（IDは'K'）へと所属学部が変更になる。
データベース内のデータについて、理学部の廃止と学生の所属変国の処理を行うSQL文を、各種整合性の維持を考慮して作成する
BIGIN;
UPDATE 学生 SET 学部ID = 'K'
WHERE 学部ID = 'R';
DELETE FROM 学部
WHERE ID = 'R';
COMMIT;






第11章
さまざまな支援機能
11.1
データベースをより速くする

検索を速くする方法
データベース内のテーブルに対しても、書籍の索引とにたものを作ることができる。

インデックスの作成と削除
データベースで作成することのできる索引情報はインデックスと呼ばれ、次のような特徴がある。

インデックスの特徴
・インデックスは、指定した列に対して作られる。
・インデックスが存在する列に対して検索が行われると、DBMSは自動的にインデックスの使用を試みるため、
  高速になる場合が多い。（検索の内容によってはインデックスの利用はできず機能が向上しない場合もある）
・インデックスには名前をつけなければならない。

特に重要なのは、インデックスが「列ごと」に作られるという点。
たとえば、家計簿テーブルの「費目ID」列に関するインデックスを作ると、
検索条件に費目IDを指定した検索は高速になる。
もし、「メモ」列でも検索することが多ければ、メモ列にもインデックスを作成するべき。

インデックスを作成するには、DDLに属する命令であるCREATE INDEX文を使う

インデックスの作成
CREATE INDEX インデックス名 ON テーブル名（列名）

インデックス名は、ほかと重複しない範囲で任意の名前を付けることができる。
この名前は、DROP INDEX文でインデックスを削除するときにも使う。

インデックスの削除
DROP INDEX インデックス名

高速化のパターン
ケース1 WHERE句による絞り込み
最もわかりやすいのは、WHERE句の絞り込み条件でインデックスを作成した例を利用する場合

DBMSの種類やインデックスの内部構造にもより、文字列比較の場合、完全一致検索だけではなく、
前方一致検索でもインデックスを利用した高速な検索が行われることがある。
ただし、部分一致検索や、後方一致検索では、通常、インデックスは利用されない。


ケース2 ORDER BY による並び替え
インデックスには並び替えを高速化する効果もあるため、ORDER BYの処理が速くなる。


ケース3 JOINによる結合の条件
結合処理は内部で並び替えを行なっているため、インデックスが設定された列を
結合条件に使うと高速になる。


インデックス設定の効果が得られやすい例
・WHERE句に頻繁に登場する例
・ORDER BY句に頻繁に登場する例
・JOINの結合条件に頻繁に登場する例（外部キーの例）


インデックスの注意点
インデックスを作成することによるデメリット
・索引情報を保存するために、ディスク容量を消費する。
・テーブルのデータが変更されるとインデックスも書き換える必要があるため、
  INSERT文、UPDATE文、DELETE文のオーバーヘッドが増える

インデックスは、実際にデータベース内に保存される索引情報なので、ディスク容量を消費する。
使い方によっては大した容量にはならないこともあるが、テーブルのデータ量が増えればインデックスとして消費される容量も
確実に増加する。
インデックスが作成されている列のデータを変更する場合、DBMSはその度にインデックス情報を更新する必要があり、
更新処理に時間がかかってしまう。


インデックスは乱用しない
インデックスによって検索性能は向上するが、書き換え時のオーバーヘッドは増加する。


11.2
データベースをより便利にする

ビューの作成とメリット
2つのSELECT文に全く同じWHERE句が記述されている。4月に関する検索を行うたびに同じ検索条件を書くのは面倒。
このような場合に便利なのが、結果表をテーブルのように扱えるビューという機能。

ビューの作成にはCREATE VIEW文を、削除にはDROP VIEW文を使う

ビューの作成と削除
CREATE VIEW ビュー名 AS SELECT文
DOROP VIEW ビュー名

ビューのメリット
・シンプルで分かりやすいSQL文を書くことができる
・権限と組み合わせて、データ参照を許可する範囲w柔軟に定めることができる


ビューの制約とデメリット
ビュー使用時の注意点
実際に実行されるSQL文は、一見するよりも負荷の高い処理になる可能性がある。


重複しない番号の管理
（1）連番が自動的に振られる特殊な列を定義できる
CREATE TABLE文で列を定義する際に「連番を振る列である」と宣言するだけで、データが追加されるタイミングで
自動的に連番が振られる列を定義することができる。


（2）連番を管理してくれる専用の道具を利用できる
シーケンスは採番した最新の値を常に記憶しており、シーケンスに指示すると
「現在の値」や「次の値」を取り出すことができる
ただし、シーケンスから値を取り出すと、その操作はすぐに確定し、
トランザクションをロールバックしてもシーケンスの値は戻らない。
これは、1つのシーケンスが複数のトランザクションから利用されることを考慮しているため。

シーケンスは、CREATE SEQUENCE文で作成し、DROP SEQUENCE文で削除することができる。

シーケンスの作成と削除
CREATE SEQUENCE シーケンス名
DROP SEQUENCE シーケンス名

（3）そのほかの方法
DBMSによっては、独自の採番機構を提供しているものもある。


データベースをより安全に使う
信頼性のために備えるべき4つの特性

これまでに学んだ安全機構
・コミットやロールバック
  途中で処理が中断しても、データが中途半端な状態にならない
・型や制約
  あらかじめ指定した種類や条件に従った値だけを格納する
・分離レベルやロック
  同時に実行しているほかの人の処理から副作用を受けない

ITの世界では、「データを正確かつ安全に取り扱うためにシステムが備えるべき4つの特性」として
ACID特性が広くしられている。
これまで学んだ安全機構は、それぞれACID特性の原子性、一貫性、分離性の3つをカバーする。

バックアップのしくみ
多くのDBMSは、万が一のデータ消失に備えてバックアップの仕組みを備えている。
それは、データベースの全内容をファイルに出力することができる

バックアップの整合性
整合性を保ちつつバックアップを行う最も簡単な方法は、データベースを停止してからバックアップを行う
オフラインバックアップ。
多くのDBMSは、稼働しながら整合性のあるバックアップデータを取得できるオンラインバックアップ性能も備えている。
この機能は、便利な反面、制約を伴うこともある。

2つのバックアップ方式
オフラインバックアップ: DBMSを停止して行うバックアップ
オンラインバックアップ: DBMSを稼働させながら行うバックアップ

ログファイルのバックアップ
バックアップを組み合わせる
データベースの内容: 低頻度（日次、週次、月次など）
ログファイルの内容: 高頻度（数分ごと〜数時間ごとなど）

データベースのログは、REDOログやアーカイブログ、またはトランザクションログなどとも呼ばれ、その内容は
それまでにデータベースを更新したすべてのSQL文にほかならない。

バックアップからのデータ復元方法
①最後に取得したデータベースのバックアップを復元する
②ログに記録されているSQL文のうち、「最後のデータベースバックアップ以降に実行されたもの」を再実行する

ログに記録されているSQL文を再実行して、障害が発生する直前の状態までデータを更新する処理のことを
ロールフォワードという。


ロールバックとロールフォワード
・ロールバック（実行した処理を取り消す）
  データベースの利用中に実行失敗やデッドロックなどを要員として、たびたび発生する。
・ロールフォワード（まだ実行されていない処理を実行する）
  障害復旧時に行われる処理であるため、滅多に発生しない。


11.4
この章で学習した内容
インデックス
・テーブルの列に対して、索引情報を生成することができる。
・インデックスが存在する列に対する検索は、多くの場合、高速になる。
・すべての検索でインデックスが使われるわけではない。
・インデックスは書き込み性能の低下を招くこともあるため乱用は禁物。

ビュー
・SELECT文の結果表を仮想的なテーブルとして扱うことができる。
・ビューを使うことでSQL文はシンプルになるが、その実体は単なるSELECT文のためDBMSの負荷は変わらない。

採番とシーケンス
・連番を作成する列定義やシーケンスを使って、連番を簡単に取得できる。
・数字と記号記号を組み合わせたような複雑な採番を行う場合は、採番テーブルを作るなどして自力で実装する必要がある。

バックアップ
・正確なデータ処理には、原子性、一貫性、分離性に永続性を加えた4特性（ACID特性）が求められる。
・記憶媒体が障害を起こした場合に備え、定期的にバックアップを取得する。
・データベースの内容だけでなく、ログファイルもバックアップしておくことで、
  障害時にはロールフォワードによって障害発生直前の状態までデータを復元できる。


11.5
練習問題
11-1
（A）ACID特性
（B）制約
（C）永続性
（D）ログファイル
（E）ロールフォワード

11-2
1.
名前、学部ID

2.学生テーブルの用途を考慮してビューを作成する場合のSQLを作成する
CREATE VIEW 学部名付き学生 AS
SELECT S.学生番号, S.名前, S.生年月日,S.血液型, S.学部ID, B.名前 AS 学部名
FROM 学生 AS S
JOIN 学部 AS B
ON S.学部ID = B.ID

3.学生情報を追加するSQLを作成する。
INSERT INTO 学生
（学籍番号, 名前, 生年月日, 血液型, 学部ID, 登録順）
VALUES
（'B1101022', '古島 進', '2002-02-12', 'A', 'K',
（SELECT NEXTBAL('ISTD')）
）

12.9
練習問題
12-1
ER図

12-3
1.
名刺テーブル
メールアドレス
名前（日本語）
名前（ローマ字）
部署名
会社名
会社郵便番号
会社住所
会社電話番号
会社FAX番号


2.
見積書
No
見積日
顧客名
件名
納期
支払条件
有効期限
合計金額
税区分
会社名
会社郵便番号
会社住所
会社電話番号
備考


見積明細
見積No(FK)
明細No
摘要
数量
単位
単価
金額




第4部
データベースで実現しよう

第12章
テーブルの設計

12.1
システムとデータベース

データベースを用いたシステムを開発するには
SQLやDBMSの機能に関する知識だけでは、データベースを用いたシステムは開発できない。要件をしっかりと理解し、
その要件をデータベース設計に適切に落とし込むための方法論を活用しなければならない。

データベース設計の流れ
データベース構築のINNPUTとOUTPUT
INPUT : 要件の一覧表（お客様から聴取したもの）
OUTPUT : DDL一式（実行すれば必要十分なテーブルが生成されるもの）


概念設計
管理すべき情報はどのようなものなのかを整理する。
データベースやシステムに関することは考えず、要件に登場する情報だけをざっくりと把握する。


論理設計
概念設計で明らかになった各情報について、RDBを使う前提で構造を整理し、詳しく具体化していく。
論理設計では「どのようなテーブルを作り、それぞれのテーブルにどのような列を作るか」まで明らかにすれば十分。
方や制約など、付随的な部分については考えない。


物理設計
特定のDBMS製品を使う前提に立ち、論理設計で明らかになった各テーブルについて、その内容を詳しく具体化していく。
すべてのテーブルのすべての列について、型、インデックス、制約、デフォルト値など、テーブル作成に必要な
すべての要素を確定させる。
この物理設計に基づいて、CREATE TABLE文などを含む一連のDDLを作成し、
最終的にデータベース内にテーブルを作成することができる。


12.2
家計管理データベースの要件

12.3
概念設計

概念設計では、要件を実現するために、抽象的な概念としてどのような「情報の塊」を管理しなければならないかを明らかにする。
この情報の塊のことをエンティティといい、通常エンティティは複数の属性を持っている。
さらに、エンティティ同士にどのような関連があるかも、この概念設計で明らかにする。

概念的なもののイメージをつかむためのヒント
エンティティー :「テーブル」ようなもの
属性 :テーブルの「列」のようなもの
関連 :「リレーションシップ」のようなもの

形のあるものだけでなく、「事実」とか「行為」みたいな形のないものもエンティティになる

ER図
概念設計の成果は、ER図と呼ばれる図にまとめることが一般的。
ER図を使うことで、エンティティ、属性、リレーションシップを俯瞰してみることができる。


ER図の記述のルール
ER図に登場する四角形はエンティティを表している。
四角形の上にはエンティティの名前が、四角形の中には属性の一覧が記述されている。
属性の一覧は、2つのグループに分けられる。四角形の中の線より上には、エンティティを一意に特定する主キーとなる属性を記述する。
複数の属性で複合主キーを構成するときは、線より上に複数の属性を記述する。
また、外部キーとなる属性には「（FK）」を付記する。

エンティティ間にリレーションシップがある場合には、エンティティ同士を線でつなぐ。
外部キーを持つエンティティは、おのずとほかのエンティティとリレーションシップを持つことがわかる。
エンティティ同士の数量的な関係を多重度やカーディナリティという。


エンティティを導き出す方法
ステップ1 候補となる用語を洗い出す
・要件の中から「名詞」を抜き出す。
・要件が実現されている姿を仮定して、そこに登場する「人」「物」「事実」「行為」
  などの用語を書き出す。

ステップ2 不要な用語を捨てる
・ほかの用語の具体例でしかないものを捨てる
  （例）「利用者」がすでにあれば、「いずみ」は捨ててよい。
・計算や集計をすれば算出可能な値は捨てる

ステップ3 関連がありそうなものをまとめる
・同じ用語に関連するものを集める。
  （例）「日付」「利用者」「内容」はいずれも「入出金行為」に関連する。なぜなら「入出金をした日付」や「入出金行為の内容」だから。

ステップ4 えんてぃてぃ名と属性名に分ける
・ステップ3でまとめたグループの中で「〜をした〜」や「〜の〜」という日本語が成り立つ場合、
  前者がエンティティ名に、後者がその属性名になる。
  （例）「入出金行為をした日付」の「入出金行為」はエンティティ名に、「日付」はその属性になる。


二重構造エンティティは作らない
ER図ではエンティティの中にエンティティをつくること（二重構造）はできない。
このような場合「入出金明細」は別のエンティティとして、外部に取り出すようにする。
このとき、外部に取り出したエンティティは、元のエンティティと関連があるはず。
元のエンティティと関連付けられるように、取り出したエンティティに、元のエンティティの主キーを外部キーの属性として追加しておく。


12.4
論理設計
論理設計ですること
概念設計で作成したER図は、あくまでも概念の世界における理想的なエンティティ構造を表しているにすぎないため、
このままの姿でデータベースに格納できるとは限らない。
そこで、利用する予定のデータベースが扱いやすい構造にエンティティを変形する作業を行う。
私たちが学習しているRDBは、「関係性のある複数の二次元表」として情報を扱う
リレーショナルデータモデルでデータを管理する。

「多対多」の分解
リレーショナルデータベースは「多対多」の関係をうまく扱うことができない。
そこで、2つのエンティティの対応を格納した中間テーブル（関連エンティティともいう）を追加することによって、
「多対多」を2つの「1対多」の関係に変換する。


キーの整理
主キーが備えるべき3つの特性
非NULL性:必ず何らかの値を持っている。
一意性:ほかと重複しない。
不変性:一度決定されたら値が変化することがない（主キーは、一貫して同じ1行を差し示す。）


正規化
論理設計における最も中心的な作業は、正規化の作業。
正規化とは、矛盾したデータを格納できないよう、テーブルを複数に分割していく作業。

整合性が崩れにくい優れたテーブル設計の原則は、1つの事実は1箇所に。
正規化という手法を用いて正しくテーブルを分割し、この原則に沿ったテーブル構造を手に入れることでヒューマンエラーを防止できる。


12.5
正規化の手順

正規化の段階
正規化によってテーブルが適切に分割された状態を正規形という。
正規形は第1正規形から第5正規形まで存在する。

正規化の流れ
手元にあるテーブル構造を、非正規形から第3正規形まで順次変形していく。

第1正規形への変形
第1正規形の目指す姿と達成条件
テーブルのすべての行のすべての列に1つずつ値が入っているべきである。
よって、「繰り返しの列」や「セルの結合」が現れてはならない。

ステップ1 繰り返しの列の部分を別の表に切り出す
まず、元のテーブルから「繰り返しの列」の部分を別テーブルとして切り出し、
切り出したテーブルに名前を付ける。

ステップ2 切り出したテーブルの仮の主キーを決める
入出金明細テーブルの主キーとなる列を決める。ステップ1で切り出した入出金明細テーブルには、
「費目ID」「費目名」「金額」の3つの例があるが、1つの入出金行為で同じ費目が複数使われることはないという要件が
あったので、「費目ID」を仮の主キーと定める。

ステップ3 主キー列をコピーして複合主キーを構成する
元のテーブルの主キー列を、切り出したテーブルにも加え、ステップ2の仮の主キーとあわせて複合主キーを構成する。
今回の場合は、入出金明細テーブルに「入出金行為ID」列を追加し、「費目ID」と併せて複合主キーを構成する。


関数従属性
「ある列Aの値が決まれば、自ずと列Bの値も決まる」という関係。
このとき、「列Bは列Aに関数従属している」という。

テーブルにおける理想的な関数従属
すべての非キー列は、主キーにきれいに関数従属しているべきである。

ここでのポイントは、「主キーにきれいに関数従属している」こと。


第2正規形への変形
第2正規形への変形は、主キーに対する「きたない関数従属」の排除が目的である。

第2正規形の目指す姿と達成条件
複合主キーを持つテーブルの場合、非キー列は、複合主キーの全体に関数従属すべきである。
よって、「複合主キーの一部の列に対してのみ関数従属する列」が含まれてはならない。

ステップ1 複合主キーの一部に関数従属する列を切り出す
複合主キーの一部の列に関数従属している列を、別のテーブルとして切り出して名前を付ける。

ステップ2 部分関数従属していた列をコピーする
切り出した列が関数従属していた列を、ステップ1で作ったテーブルにコピーして主キーとする。


第3正規形への変形
第3正規形の目指す姿と達成条件
非キー列は、主キーに直接、関数従属すべきである。
よって、「主キーに関数従属する列にさらに関数従属する列」は存在してはならない。

「主キーに対する間接的な関数従属」をきたない関数従属とみなし、それを排除しようとしている。
間接的に関数従属することを、専門用語では推移関数従属という。

推移関数従属の排除
ステップ1 間接的に主キーに関数従属する列を切り出す
間接的に主キーに関数従属している列を、別のテーブルとして切り出して名前を付ける。

ステップ2 直接的に関数従属していた列をコピーする
切り出した列が関数従属していた列を、切り出したテーブルにコピーして主キーとする。

3つの正規化で排除しようとするもの
第1正規形への変形:繰り返し列
第2正規形への変形:複合主キーの一部への関数従属（部分関数従属）
第3正規形への変形:間接的な関数従属（推移関数従属）


12.6
物理設計

物理設計の流れ
論理設計後、どのDBMS製品を利用するかを確定した上で行うのが物理設計。
DBMS製品がサポートする型や制約、インデックス、利用するハードウェアなどの制約を考慮し、全テーブルについて詳細な設計を確定させる。
完成した物理モデルは、そのままDDLに変換できる内容となる。


物理設計の内容
①最終的なテーブル名、列名を決定する
論理設計までは、わかりやすいように日本語のテーブル名や列名をつかうことが一般的ですが、
最終的にはアルファベッドを用いた名前を付ける場合が多い。
最終的にデータベース内に作られるテーブル名や列名を、物理名という。
対して、論理設計までの段階で利用してきた名前は論理名という。

②列の型を決定する
各列に対して指定する型を決定する。

③制約、デフォルト値を決定する
各テーブルや各列に対して、設定する制約を決定する。
型と同じく、利用できる制約やデフォルト値はDBMS製品によって異なることがあるため、
物理設計の段階で決定する。

④インデックスを決定する
どの列にインデックスを設定するのかについても、物理設計で決定する事柄。
DBMS製品のインデックス特性やその列を利用する状況などを総合的に考慮して決定する。

⑤その他
利便性を考慮してビューを作成したり、性能のためにあえて正規化を崩したり、
巨大なテーブルを分割したりする作業が行われることもある。

このような過程で確定した物理モデルは情報量が多く、ER図で表現できない仕様も含んでいる。
そのため、通常はER図とは別に「テーブル設計仕様書」などの名称で呼ばれる別文書に取りまとめられる。


12.7
正規化されたデータの利用

家計管理データベースを使う
管理に適した形、利用に適した形
管理するときは: データは複数のテーブルに分割してあるほうがよい。
利用するときは: データは1つのテーブルに結合してある方がよい。

情報の2つの形態を変換する技術
正規化: 現実世界の冗長な情報を、管理に適する複数の表の形に変換
結合: IT世界の断片的な情報を、利用に適する統合した形に変換

12.8
この章で学習した内容

データベース設計
・お客様から聴取した要件は、概念設計、論理設計、物理設計を経て、DDLやDBMSの各種設定に落とし込む。
・概念設計では、取り扱うエンティティとその関連を明らかにする。
・論理設計では、キー設計や正規化などを行いRDB用のモデルに変換する。
・物理設計では、採用するDBMS製品に依存した詳細な設計に落とし込む。

エンティティの関係
・エンティティ同士の多重度には「1対1」「1対多」「多対多」がある。
・ER図を用いてエンティティの関係を図示できる。

論理モデルと正規化
・「多対多」の関係は、中間テーブルを使って「1対多」に変換する
・主キーが存在しないテーブルには、人工キーを追加する
・「1対多」を形成する概念は別テーブルとして設計する（第1正規形）
・複合主キーの一部に関数従属する部分を別テーブルに分割する（第2正規形）
・主キーに対して間接的に関数従属する部分を別テーブルに分割する（第3正規形）
・論理モデルには、見落としがないことが重要である
・お客様の理想を起点とするトップダウンアプローチと、お客様の現実を起点とするボトムアップアプローチを
  組み合わせてもれを防ぐ